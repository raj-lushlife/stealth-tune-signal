<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Over-air presence beacon using imperceptible audio drops">
  <title>Presence Beacon - Imperceptible Audio Drops</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a1a;
      color: #e0e0e0;
      padding: 16px;
      line-height: 1.6;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      font-size: 24px;
      margin-bottom: 16px;
      text-align: center;
      color: #fff;
    }

    .instructions {
      background: #2a2a2a;
      padding: 16px;
      border-radius: 8px;
      margin-bottom: 24px;
      border-left: 4px solid #4CAF50;
    }

    .instructions h2 {
      font-size: 18px;
      margin-bottom: 12px;
      color: #4CAF50;
    }

    .instructions ol {
      margin-left: 20px;
    }

    .instructions li {
      margin: 8px 0;
    }

    .global-controls {
      background: #2a2a2a;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 24px;
      text-align: center;
    }

    .btn {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 14px 28px;
      font-size: 16px;
      border-radius: 6px;
      cursor: pointer;
      margin: 8px;
      min-width: 140px;
      transition: background 0.2s;
    }

    .btn:hover {
      background: #45a049;
    }

    .btn:disabled {
      background: #555;
      cursor: not-allowed;
    }

    .btn-stop {
      background: #f44336;
    }

    .btn-stop:hover {
      background: #da190b;
    }

    .btn-secondary {
      background: #2196F3;
    }

    .btn-secondary:hover {
      background: #0b7dda;
    }

    .status {
      margin-top: 16px;
      padding: 12px;
      background: #333;
      border-radius: 6px;
      font-size: 14px;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      margin-bottom: 24px;
    }

    @media (max-width: 968px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
    }

    .section {
      background: #2a2a2a;
      padding: 24px;
      border-radius: 8px;
    }

    .section h2 {
      font-size: 20px;
      margin-bottom: 20px;
      color: #4CAF50;
      border-bottom: 2px solid #4CAF50;
      padding-bottom: 8px;
    }

    .control-group {
      margin-bottom: 20px;
    }

    .control-group label {
      display: block;
      margin-bottom: 6px;
      font-size: 14px;
      color: #bbb;
    }

    .control-group input[type="number"],
    .control-group input[type="file"] {
      width: 100%;
      padding: 10px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 14px;
    }

    .control-group input[type="checkbox"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }

    .checkbox-wrapper {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .readout {
      background: #1a1a1a;
      padding: 12px;
      border-radius: 4px;
      margin-top: 8px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      color: #4CAF50;
    }

    .button-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 16px;
    }

    .subsection {
      background: #333;
      padding: 16px;
      border-radius: 6px;
      margin-top: 16px;
    }

    .subsection h3 {
      font-size: 16px;
      margin-bottom: 12px;
      color: #2196F3;
    }

    .presence-badge {
      margin-top: 20px;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      font-size: 18px;
      font-weight: bold;
      background: #555;
      color: #999;
      border: 3px solid #555;
    }

    .presence-badge.verified {
      background: #1b5e20;
      color: #4CAF50;
      border-color: #4CAF50;
      animation: pulse 2s infinite;
    }
    
    .fsm-state-pill {
      display: inline-block;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: bold;
      margin-top: 12px;
      background: #333;
      color: #999;
      border: 2px solid #555;
    }
    
    .fsm-state-pill.idle {
      background: #333;
      color: #999;
      border-color: #555;
    }
    
    .fsm-state-pill.preamble {
      background: #1a4d7a;
      color: #64B5F6;
      border-color: #2196F3;
    }
    
    .fsm-state-pill.code {
      background: #7a4d1a;
      color: #FFB74D;
      border-color: #FF9800;
    }
    
    .fsm-state-pill.unlocked {
      background: #1b5e20;
      color: #4CAF50;
      border-color: #4CAF50;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .warning-banner {
      background: #ff9800;
      color: #000;
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 16px;
      text-align: center;
      font-weight: bold;
      display: none;
    }

    .warning-banner.show {
      display: block;
    }

    input[type="file"] {
      padding: 8px !important;
    }

    .grid-2col {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    @media (max-width: 640px) {
      .grid-2col {
        grid-template-columns: 1fr;
      }
      .btn {
        width: 100%;
      }
    }

    .band-display {
      display: flex;
      gap: 12px;
      margin-top: 12px;
    }

    .band-meter {
      flex: 1;
      background: #1a1a1a;
      padding: 12px;
      border-radius: 4px;
      text-align: center;
    }

    .band-meter .label {
      font-size: 12px;
      color: #bbb;
      margin-bottom: 4px;
    }

    .band-meter .value {
      font-size: 18px;
      font-weight: bold;
      color: #4CAF50;
      font-family: 'Courier New', monospace;
    }

    .log-console {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 12px;
      margin-top: 16px;
      max-height: 400px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      line-height: 1.4;
    }

    .log-console .log-entry {
      margin: 2px 0;
      color: #aaa;
    }

    .log-console .log-entry.success {
      color: #4CAF50;
    }

    .log-console .log-entry.error {
      color: #f44336;
    }

    .log-console .log-entry.warning {
      color: #ff9800;
    }

    .log-console .log-entry.info {
      color: #2196F3;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üéµ Presence Beacon - Spectral Verification</h1>

    <div class="instructions">
      <h2>How to Use (Spectral Beacon 2)</h2>
      <ol>
        <li><strong>Start RX First</strong> - Click "Start RX" on listener device to calibrate noise floor (5 seconds)</li>
        <li><strong>Wait for "‚úÖ Calibrated"</strong> - Baseline noise measurement completes</li>
        <li><strong>Start TX</strong> - Click "Start TX" on encoder device (sends burst every 8s)</li>
        <li><strong>Wait for Detection</strong> - RX will show "‚úÖ Presence Verified!" when correlation peak detected (Z‚â•5, PSR‚â•7dB)</li>
        <li><strong>Normal Use</strong> - System works through music, talking, ambient noise. Claps/shouts are vetoed automatically.</li>
      </ol>
      <p><strong>Expected:</strong> Verification in ‚â§10s at 20-40cm distance with iPhone mic.</p>
    </div>
    
    <div class="global-controls">
      <div class="control-group">
        <label style="color: #4CAF50; font-size: 16px; font-weight: bold;">Detection Mode:</label>
        <div style="display: flex; gap: 16px; margin-top: 12px; justify-content: center;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 12px 20px; background: #333; border-radius: 6px; border: 2px solid #4CAF50;">
            <input type="radio" name="detectionMode" value="spectral" checked style="width: auto;">
            <span style="color: #e0e0e0; font-weight: bold;">üéØ Spectral Beacon (Recommended)</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 12px 20px; background: #333; border-radius: 6px; border: 2px solid #666;">
            <input type="radio" name="detectionMode" value="legacy" style="width: auto;">
            <span style="color: #999;">Legacy Notch Test</span>
          </label>
        </div>
      </div>
    </div>

    <div class="warning-banner" id="iosWarning">
      ‚ö†Ô∏è Audio Context Interrupted - Tap "Resume Audio" to continue
    </div>

    <div class="global-controls">
      <button id="startAudioBtn" class="btn">‚ñ∂ Start Audio</button>
      <button id="resumeAudioBtn" class="btn btn-secondary" style="display:none;">Resume Audio</button>
      <div class="status">
        <div><strong>Status:</strong> <span id="globalStatus">Not started</span></div>
        <div><strong>Sample Rate:</strong> <span id="sampleRate">‚Äî</span> Hz</div>
        <div><strong>Audio Context State:</strong> <span id="ctxState">‚Äî</span></div>
      </div>
    </div>

    <div class="main-grid">
      <!-- OFFLINE ENCODER SECTION -->
      <div class="section">
        <h2>üéõÔ∏è OFFLINE ENCODER (Test & Verify)</h2>
        
        <div class="control-group">
          <label>Audio File (mp3/wav):</label>
          <input type="file" id="offlineFile" accept="audio/*">
          <div class="readout">Upload a file to encode and compare original vs encoded playback</div>
        </div>

        <!-- Spectral Offline Params -->
        <div class="subsection" id="offlineSpectralParams">
          <h3>Spectral Beacon Parameters</h3>
          <div class="grid-2col">
            <div class="control-group">
              <label>Center Frequency (Hz):</label>
              <input type="number" id="offlineSpectralCenter" value="6000" min="4000" max="18000" step="100">
            </div>
            <div class="control-group">
              <label>Bin Spacing (Hz):</label>
              <input type="number" id="offlineSpectralSpacing" value="500" min="30" max="1000" step="50">
            </div>
            <div class="control-group">
              <label>Symbol Duration (ms):</label>
              <input type="number" id="offlineSpectralDuration" value="60" min="40" max="120" step="5">
            </div>
            <div class="control-group">
              <label>Code Repeats:</label>
              <input type="number" id="offlineSpectralRepeats" value="2" min="1" max="5">
            </div>
            <div class="control-group">
              <label>Boost/Cut (¬±dB):</label>
              <input type="number" id="offlineSpectralGain" value="52" min="0.5" max="60" step="0.5">
            </div>
            <div class="control-group">
              <label>Start Time (s):</label>
              <input type="number" id="offlineSpectralStart" value="2" min="0" max="60" step="0.1">
            </div>
          </div>
        </div>

        <!-- Legacy Offline Params -->
        <div class="subsection" id="offlineLegacyParams" style="display:none;">
          <h3>Drop Parameters</h3>
          <div class="grid-2col">
            <div class="control-group">
              <label>Drop Center (Hz):</label>
              <input type="number" id="offlineDropCenter" value="8000" min="1000" max="20000">
            </div>
            <div class="control-group">
              <label>Drop Bandwidth (Hz):</label>
              <input type="number" id="offlineDropBw" value="600" min="100" max="2000">
            </div>
            <div class="control-group">
              <label>Drop Depth (dB):</label>
              <input type="number" id="offlineDropDepth" value="-12" min="-40" max="-0.5" step="0.5">
            </div>
            <div class="control-group">
              <label>Drop Length (ms):</label>
              <input type="number" id="offlineDropLen" value="1000" min="50" max="5000">
            </div>
            <div class="control-group">
              <label>Drop Start Time (s):</label>
              <input type="number" id="offlineDropStart" value="2" min="0" max="60" step="0.1">
            </div>
            <div class="control-group">
              <label>Number of Drops:</label>
              <input type="number" id="offlineDropCount" value="3" min="1" max="20">
            </div>
          </div>
          <div class="readout">
            üí° Tip: Use extreme values (e.g., -20dB depth, 2000ms length) to clearly hear the encoding
          </div>
        </div>

        <div class="button-row">
          <button id="processOfflineBtn" class="btn">Process File</button>
          <button id="downloadOfflineBtn" class="btn btn-secondary" disabled>Download Encoded</button>
        </div>

        <div class="subsection" id="offlinePlayback" style="display:none;">
          <h3>Playback Comparison</h3>
          <div class="control-group">
            <label>Original:</label>
            <audio id="originalAudio" controls style="width:100%; margin-bottom:12px;"></audio>
          </div>
          <div class="control-group">
            <label>Encoded (with drops):</label>
            <audio id="encodedAudio" controls style="width:100%;"></audio>
          </div>
        </div>

        <div class="readout" id="offlineReadout">
          <div><strong>Status:</strong> <span id="offlineStatus">Ready - upload a file</span></div>
          <div><strong>File Duration:</strong> <span id="offlineDuration">‚Äî</span></div>
          <div><strong>Drops Encoded:</strong> <span id="offlineDropsEncoded">0</span></div>
        </div>
      </div>

      <!-- LIVE ENCODER (TX) SECTION -->
      <div class="section">
        <h2>üì° LIVE ENCODER (TX)</h2>

        <div class="control-group">
          <label>Music Bed (mp3/wav, optional):</label>
          <input type="file" id="bedFile" accept="audio/*">
          <div class="readout">If no file: generates pink noise bed at low level for demo</div>
        </div>

        <!-- Spectral Beacon Parameters -->
        <div class="subsection" id="spectralTxParams">
          <h3>Spectral Beacon Parameters</h3>
          <div class="grid-2col">
            <div class="control-group">
              <label>Center Frequency (Hz):</label>
              <input type="number" id="spectralCenterFreq" value="6000" min="4000" max="18000" step="100">
            </div>
            <div class="control-group">
              <label>Bin Spacing (Hz):</label>
              <input type="number" id="spectralBinSpacing" value="500" min="30" max="1000" step="50">
            </div>
            <div class="control-group">
              <label>Symbol Duration (ms):</label>
              <input type="number" id="spectralSymbolDuration" value="60" min="40" max="120" step="5">
            </div>
            <div class="control-group">
              <label>Code Repeats:</label>
              <input type="number" id="spectralRepeats" value="2" min="1" max="5">
            </div>
            <div class="control-group">
              <label>Boost/Cut (¬±dB):</label>
              <input type="number" id="spectralGain" value="52" min="3" max="60" step="0.5">
              <div class="readout" style="font-size:10px; margin-top:4px;">
                3-12dB: Subtle | 15-24dB: Balanced | 30-40dB: Maximum signal strength
              </div>
            </div>
            <div class="control-group">
              <label>Burst Interval (s):</label>
              <input type="number" id="spectralBurstInterval" value="8" min="2" max="15" step="1">
            </div>
          </div>
          <div class="readout">
            üí° <strong>Testing Guide:</strong> Start at ¬±12dB for reliable detection. Once working, gradually reduce to find the minimum imperceptible level for your audio content (music may tolerate 6-8dB, speech needs 10-15dB). For speaker‚Üímic testing, 12-18dB recommended.
          </div>
        </div>

        <!-- Legacy Notch Parameters -->
        <div class="subsection" id="legacyTxParams" style="display:none;">
          <h3>Drop Parameters</h3>
          <div class="grid-2col">
            <div class="control-group">
              <label>Drop Center (Hz):</label>
              <input type="number" id="dropCenter" value="8000" min="1000" max="20000">
            </div>
            <div class="control-group">
              <label>Drop Bandwidth (Hz):</label>
              <input type="number" id="dropBw" value="600" min="100" max="2000">
            </div>
            <div class="control-group">
              <label>Drop Depth (dB):</label>
              <input type="number" id="dropDepth" value="-3.5" min="-4" max="-0.5" step="0.1">
            </div>
            <div class="control-group">
              <label>Drop Length (ms):</label>
              <input type="number" id="dropLen" value="200" min="50" max="500">
            </div>
            <div class="control-group">
              <label>Fade In (ms):</label>
              <input type="number" id="fadeIn" value="12" min="5" max="50">
            </div>
            <div class="control-group">
              <label>Fade Out (ms):</label>
              <input type="number" id="fadeOut" value="12" min="5" max="50">
            </div>
          </div>
        </div>

        <div class="subsection">
          <h3>Scheduling</h3>
          <div class="control-group">
            <div class="checkbox-wrapper">
              <input type="checkbox" id="pinkNoiseOnly">
              <label for="pinkNoiseOnly">Pink Noise Only (No Drops) - for testing</label>
            </div>
          </div>
          <div class="grid-2col">
            <div class="control-group">
              <label>Repeat Every (s):</label>
              <input type="number" id="repeatEvery" value="15" min="2" max="60" step="0.5">
            </div>
            <div class="control-group">
              <label>Jitter ¬± (s):</label>
              <input type="number" id="jitter" value="0.5" min="0" max="10" step="0.5">
            </div>
          </div>
        </div>

        <div class="subsection">
          <h3>Masking Gate</h3>
          <div class="control-group">
            <div class="checkbox-wrapper">
              <input type="checkbox" id="maskingOn" checked>
              <label for="maskingOn">Enable Masking (schedule drops only during loud moments)</label>
            </div>
          </div>
          <div class="grid-2col">
            <div class="control-group">
              <label>Window (ms):</label>
              <input type="number" id="maskWin" value="50" min="20" max="200">
            </div>
            <div class="control-group">
              <label>Hop (ms):</label>
              <input type="number" id="maskHop" value="25" min="10" max="100">
            </div>
            <div class="control-group">
              <label>Threshold Rel. dB:</label>
              <input type="number" id="maskThreshold" value="-18" min="-30" max="0" step="0.5">
            </div>
          </div>
        </div>

        <div class="control-group">
          <label>Output Gain (dB):</label>
          <input type="number" id="outputGain" value="0" min="-20" max="6" step="0.5">
        </div>

        <div class="button-row">
          <button id="startTxBtn" class="btn">Start TX</button>
          <button id="stopTxBtn" class="btn btn-stop" disabled>Stop TX</button>
          <button id="smokeTestBtn" class="btn btn-secondary">Smoke Test TX</button>
        </div>

        <div class="readout" id="txReadout">
          <div><strong>Status:</strong> <span id="txStatus">Idle</span></div>
          <div><strong>Next Drop In:</strong> <span id="nextDropCountdown">‚Äî</span></div>
          <div><strong>Last Scheduled:</strong> <span id="lastScheduled">‚Äî</span></div>
          <div><strong>Last Masking RMS:</strong> <span id="lastMaskingRms">‚Äî</span></div>
          <div><strong>Total Drops:</strong> <span id="totalDrops">0</span></div>
        </div>
      </div>

      <!-- LISTENER (RX) SECTION -->
      <div class="section">
        <h2>üé§ LISTENER (RX)</h2>

        <!-- Spectral Beacon RX -->
        <div id="spectralRxSection">
          <div class="warning-banner show" style="background: #2196F3; color: white; display: block;">
            ‚ö†Ô∏è Start RX FIRST (before TX) to calibrate noise baseline!
          </div>
          <div class="subsection">
            <h3>Correlation Detection</h3>
            <div class="band-display">
              <div class="band-meter">
                <div class="label">Correlation Peak</div>
                <div class="value" id="corrPeak">‚Äî</div>
              </div>
              <div class="band-meter">
                <div class="label">Z-Score</div>
                <div class="value" id="corrZScore">‚Äî</div>
              </div>
              <div class="band-meter">
                <div class="label">PSR (dB)</div>
                <div class="value" id="corrPSR">‚Äî</div>
              </div>
              <div class="band-meter">
                <div class="label">Loudness</div>
                <div class="value" id="loudnessLevel">‚Äî</div>
              </div>
            </div>
            <div class="readout" id="baselineReadout">
              <div><strong>Status:</strong> <span id="baselineStatus">Waiting to start...</span></div>
              <div><strong>Baseline Noise:</strong> <span id="baselineNoise">Not calibrated</span></div>
              <div><strong>Detection Threshold:</strong> <span id="detectionThreshold">‚Äî</span></div>
              <div><strong>FSM State:</strong> <span id="fsmStatePill" class="fsm-state-pill idle">IDLE</span></div>
            </div>
          </div>
        </div>

        <!-- Legacy Notch RX -->
        <div id="legacyRxSection" style="display:none;">
          <div class="subsection">
            <h3>Band Definitions (Hz)</h3>
          <div class="control-group">
            <label>Notch Band:</label>
            <div class="grid-2col">
              <input type="number" id="notchLow" value="7700" min="1000" max="20000" placeholder="Low">
              <input type="number" id="notchHigh" value="8300" min="1000" max="20000" placeholder="High">
            </div>
          </div>
          <div class="control-group">
            <label>Guard Band Low:</label>
            <div class="grid-2col">
              <input type="number" id="guardLoLow" value="7000" min="1000" max="20000" placeholder="Low">
              <input type="number" id="guardLoHigh" value="7600" min="1000" max="20000" placeholder="High">
            </div>
          </div>
          <div class="control-group">
            <label>Guard Band High:</label>
            <div class="grid-2col">
              <input type="number" id="guardHiLow" value="8400" min="1000" max="20000" placeholder="Low">
              <input type="number" id="guardHiHigh" value="9000" min="1000" max="20000" placeholder="High">
            </div>
          </div>
        </div>

            <div class="subsection">
              <h3>Detection Parameters</h3>
              <div class="grid-2col">
                <div class="control-group">
                  <label>Ratio Threshold (dB):</label>
                  <input type="number" id="ratioThreshold" value="1.5" min="0" max="10" step="0.1">
                </div>
                <div class="control-group">
                  <label>Hits Required:</label>
                  <input type="number" id="hitsRequired" value="2" min="1" max="10">
                </div>
                <div class="control-group">
                  <label>Window (s):</label>
                  <input type="number" id="windowS" value="12" min="2" max="60">
                </div>
                <div class="control-group">
                  <label>Min Inter-Hit Spacing (s):</label>
                  <input type="number" id="minInterHit" value="0.5" min="0.1" max="5" step="0.1">
                </div>
              </div>
            </div>

            <div class="band-display">
              <div class="band-meter">
                <div class="label">Notch</div>
                <div class="value" id="notchPower">‚Äî dB</div>
              </div>
              <div class="band-meter">
                <div class="label">Guard Avg</div>
                <div class="value" id="guardPower">‚Äî dB</div>
              </div>
              <div class="band-meter">
                <div class="label">Ratio</div>
                <div class="value" id="ratioPower">‚Äî dB</div>
              </div>
            </div>

            <div class="readout" id="rxReadout">
              <div><strong>Status:</strong> <span id="rxStatus">Idle</span></div>
              <div><strong>Drops Detected:</strong> <span id="individualDrops">0</span></div>
              <div><strong>Valid Hits:</strong> <span id="validPairs">0</span> / <span id="hitsReq">2</span></div>
              <div><strong>Last Hit Time:</strong> <span id="lastHitTime">‚Äî</span></div>
              <div><strong>Total Hits:</strong> <span id="totalHits">0</span></div>
            </div>
          </div>
        </div>

        <div style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px;">
          <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
            <input type="checkbox" id="iphoneMode" style="width: 18px; height: 18px; cursor: pointer;">
            <span style="font-weight: 600;">üì± iPhone Mode</span>
            <span style="opacity: 0.7; font-size: 0.9em;">(Adaptive: corr ‚â•0.15 + 3 votes, PSR ‚â•5dB, Z ‚â•2.2, amp ‚â§75dB)</span>
          </label>
        </div>

        <div style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px;">
          <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
            <input type="checkbox" id="overAirMode" style="width: 18px; height: 18px; cursor: pointer;">
            <span style="font-weight: 600;">üåê Over-Air Mode</span>
            <span style="opacity: 0.7; font-size: 0.9em;">(Bypass local TX check - enable when TX is on another device)</span>
          </label>
        </div>

        <div class="button-row">
          <button id="startRxBtn" class="btn">Start RX</button>
          <button id="stopRxBtn" class="btn btn-stop" disabled>Stop RX</button>
          <button id="resetRxBtn" class="btn btn-secondary">Reset Detection</button>
          <button id="recalibrateBtn" class="btn btn-secondary" disabled>Recalibrate Baseline</button>
        </div>

        <div class="presence-badge" id="presenceBadge">
          ‚è≥ Waiting for Presence...
        </div>
      </div>
    </div>

    <!-- Live Log Console -->
    <div class="container" style="margin-top: 24px;">
      <div class="section">
        <h2>üìã Live Debug Console</h2>
        <div class="log-console" id="liveLogConsole">
          <div class="log-entry">Waiting for system to start...</div>
        </div>
        <button class="btn btn-secondary" onclick="document.getElementById('liveLogConsole').innerHTML = '';">Clear Logs</button>
      </div>
    </div>
  </div>

  <script>
    // ==================== LOG INTERCEPTOR ====================
    const logConsole = [];
    const MAX_LOGS = 200;
    const originalConsoleLog = console.log;
    const originalConsoleError = console.error;
    const originalConsoleWarn = console.warn;

    function addLogToUI(message, type = 'info') {
      const consoleEl = document.getElementById('liveLogConsole');
      if (!consoleEl) return;

      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = message;
      
      consoleEl.appendChild(entry);
      
      // Auto-scroll to bottom
      consoleEl.scrollTop = consoleEl.scrollHeight;
      
      // Limit log entries
      while (consoleEl.children.length > MAX_LOGS) {
        consoleEl.removeChild(consoleEl.firstChild);
      }
    }

    console.log = function(...args) {
      const message = args.join(' ');
      originalConsoleLog.apply(console, args);
      
      let type = 'info';
      if (message.includes('‚úÖ') || message.includes('üéâ')) type = 'success';
      else if (message.includes('‚ùå') || message.includes('‚ö†Ô∏è')) type = 'error';
      else if (message.includes('üîç') || message.includes('üìä')) type = 'info';
      
      addLogToUI(message, type);
    };

    console.error = function(...args) {
      const message = args.join(' ');
      originalConsoleError.apply(console, args);
      addLogToUI(message, 'error');
    };

    console.warn = function(...args) {
      const message = args.join(' ');
      originalConsoleWarn.apply(console, args);
      addLogToUI(message, 'warning');
    };

    console.log('Presence Beacon loaded. Click "Start Audio" to begin.');
    
    // ==================== GLOBAL STATE ====================
    let audioContext = null;
    let masterGain = null;
    let txRunning = false;
    let rxRunning = false;
    let currentMode = 'spectral'; // 'spectral' or 'legacy'

    // TX State
    let bedBuffer = null;
    let bedSource = null;
    let peakingEQ = null;
    let dropScheduleTimer = null;
    let nextDropTime = null;
    let candidateFrames = []; // {time, rms} for masking
    let globalRMS = 0;
    let totalDropsScheduled = 0;

    // Spectral Beacon TX State
    let spectralFilters = { binA: null, binB: null };
    let spectralTransmitTimer = null;

    // RX State
    let micStream = null;
    let micSource = null;
    let analyser = null;
    let rxInterval = null;
    let hitTimestamps = [];  // Valid drop timestamps
    let lastHitTime = 0;
    let totalHitsDetected = 0;
    let presenceVerified = false;
    let bandFloors = { notch: -120, guardLo: -120, guardHi: -120 };
    let bandHistory = { notch: [], guardLo: [], guardHi: [] };  // Rolling window for baseline
    let dropFrameCount = 0;  // Count consecutive frames showing drop pattern
    let lastDropDetectionTime = 0;  // Cooldown tracker to prevent multiple detections of same drop

    // Spectral Beacon RX State - FSM Approach
    let spectralSymbolBuffer = [];  // Buffered delta values
    let spectralCorrelationHistory = [];  // For Z-score calculation and sidelobe calculation
    let spectralBroadbandEMA = -100; // EMA for broadband noise veto (start low, converges up)
    
    // FSM State Machine
    let fsmState = 'IDLE'; // IDLE ‚Üí PREAMBLE_LOCK ‚Üí CODE_LOCK ‚Üí UNLOCKED
    let fsmStateStartTime = 0;
    let fsmLockoutUntil = 0; // 45s cooldown after UNLOCKED
    
    // Preamble detection
    let preambleDetectionStart = 0;
    let preambleDriftEstimate = 0;
    let preambleFlipHistory = []; // Track A/B flips
    
    // Code correlation tracking
    let codeDetectionAttempts = [];
    let codeRepeatTimestamps = [];
    
    // Adaptive baseline calibration
    let baselineCalibrated = false;
    let baselineCorrelationMean = 0;
    let baselineCorrelationStdDev = 0;
    let baselineCalibrationSamples = [];
    
    // Broadband baseline (for quiet gate)
    let baselineBroadbandMean = -100;
    let baselineBroadbandStdDev = 0;
    let baselineBroadbandSamples = [];
    
    // Energy & guard baselines
    let baselineEnergySum = -100; // E(A) + E(B) baseline
    let baselineGuardLo = -100;
    let baselineGuardHi = -100;
    
    // PN-31 Gold Code for spectral beacon (¬±1 sequence)
    const PN31_CODE = [1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,1,1];

    // ==================== UTILITY FUNCTIONS ====================
    
    function updateStatus(msg) {
      document.getElementById('globalStatus').textContent = msg;
    }

    function updateCtxState() {
      if (audioContext) {
        document.getElementById('ctxState').textContent = audioContext.state;
        if (audioContext.state === 'interrupted') {
          document.getElementById('iosWarning').classList.add('show');
        } else {
          document.getElementById('iosWarning').classList.remove('show');
        }
      }
    }

    function dbToLinear(db) {
      return Math.pow(10, db / 20);
    }

    function linearToDb(linear) {
      return 20 * Math.log10(Math.max(linear, 1e-10));
    }

    function clamp(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }

    function randomJitter(jitterS) {
      return (Math.random() * 2 - 1) * jitterS;
    }
    
    function updateFSMStateDisplay() {
      const pill = document.getElementById('fsmStatePill');
      if (!pill) return;
      
      pill.className = 'fsm-state-pill';
      
      switch(fsmState) {
        case 'IDLE':
          pill.textContent = 'IDLE';
          pill.classList.add('idle');
          break;
        case 'PREAMBLE_LOCK':
          pill.textContent = 'PREAMBLE_LOCK';
          pill.classList.add('preamble');
          break;
        case 'CODE_LOCK':
          pill.textContent = 'CODE_LOCK';
          pill.classList.add('code');
          break;
        case 'UNLOCKED':
          pill.textContent = 'üîì UNLOCKED';
          pill.classList.add('unlocked');
          break;
      }
    }

    // ==================== PINK NOISE GENERATOR ====================
    
    function generatePinkNoise(duration, sampleRate) {
      const length = duration * sampleRate;
      const buffer = audioContext.createBuffer(1, length, sampleRate);
      const output = buffer.getChannelData(0);
      
      console.log(`üéµ PINK NOISE: Generating ${duration}s (${length.toLocaleString()} samples @ ${sampleRate}Hz)`);
      
      let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
      for (let i = 0; i < length; i++) {
        const white = Math.random() * 2 - 1;
        b0 = 0.99886 * b0 + white * 0.0555179;
        b1 = 0.99332 * b1 + white * 0.0750759;
        b2 = 0.96900 * b2 + white * 0.1538520;
        b3 = 0.86650 * b3 + white * 0.3104856;
        b4 = 0.55000 * b4 + white * 0.5329522;
        b5 = -0.7616 * b5 - white * 0.0168980;
        output[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
        b6 = white * 0.115926;
      }
      
      // NUCLEAR BOOST: Increased level from 0.15 to 0.6 (4√ó louder)
      for (let i = 0; i < length; i++) {
        output[i] *= 0.6;
      }
      
      // Calculate and log RMS level
      let sumSq = 0;
      for (let i = 0; i < length; i++) {
        sumSq += output[i] * output[i];
      }
      const rms = Math.sqrt(sumSq / length);
      const rmsDb = linearToDb(rms);
      console.log(`  ‚îî‚îÄ Generated RMS: ${rms.toFixed(6)} (${rmsDb.toFixed(2)} dBFS)`);
      
      return buffer;
    }

    // ==================== RMS PRE-SCAN FOR MASKING ====================
    
    async function preScanForMasking(buffer) {
      const maskWinMs = parseFloat(document.getElementById('maskWin').value);
      const maskHopMs = parseFloat(document.getElementById('maskHop').value);
      const maskThresholdDb = parseFloat(document.getElementById('maskThreshold').value);
      
      const sampleRate = buffer.sampleRate;
      const winSamples = Math.floor((maskWinMs / 1000) * sampleRate);
      const hopSamples = Math.floor((maskHopMs / 1000) * sampleRate);
      
      // Use offline context for analysis
      const offlineCtx = new OfflineAudioContext(1, buffer.length, sampleRate);
      const source = offlineCtx.createBufferSource();
      source.buffer = buffer;
      source.connect(offlineCtx.destination);
      source.start(0);
      
      const rendered = await offlineCtx.startRendering();
      const channelData = rendered.getChannelData(0);
      
      // Compute global RMS
      let sumSq = 0;
      for (let i = 0; i < channelData.length; i++) {
        sumSq += channelData[i] * channelData[i];
      }
      globalRMS = Math.sqrt(sumSq / channelData.length);
      const globalRmsDb = linearToDb(globalRMS);
      
      // Sliding window RMS
      candidateFrames = [];
      for (let i = 0; i + winSamples < channelData.length; i += hopSamples) {
        let winSumSq = 0;
        for (let j = 0; j < winSamples; j++) {
          const sample = channelData[i + j];
          winSumSq += sample * sample;
        }
        const winRms = Math.sqrt(winSumSq / winSamples);
        const winRmsDb = linearToDb(winRms);
        const time = i / sampleRate;
        
        // Check if meets masking threshold
        if (winRmsDb >= globalRmsDb + maskThresholdDb) {
          candidateFrames.push({ time, rms: winRmsDb });
        }
      }
      
      console.log(`Pre-scan complete: globalRMS=${globalRmsDb.toFixed(2)} dB, candidates=${candidateFrames.length}`);
    }

    // ==================== AUDIO CONTEXT SETUP ====================
    
    async function initAudioContext() {
      if (audioContext) {
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }
        return;
      }
      
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioContext.createGain();
      masterGain.connect(audioContext.destination);
      
      document.getElementById('sampleRate').textContent = audioContext.sampleRate;
      updateStatus('Audio context ready');
      updateCtxState();
      
      // iOS recovery on visibility change
      document.addEventListener('visibilitychange', async () => {
        if (!document.hidden && audioContext && audioContext.state === 'suspended') {
          await audioContext.resume();
          updateCtxState();
        }
      });
      
      // Monitor state changes
      audioContext.addEventListener('statechange', () => {
        updateCtxState();
      });
    }

    // ==================== TX: ENCODER ====================
    
    async function startTX() {
      console.log('üé¨ startTX() called');
      console.log(`  ‚îú‚îÄ txRunning: ${txRunning}`);
      console.log(`  ‚îú‚îÄ audioContext: ${!!audioContext}`);
      console.log(`  ‚îî‚îÄ currentMode: ${currentMode}`);
      
      if (txRunning) {
        console.log('‚ö†Ô∏è TX already running, returning');
        return;
      }
      
      if (!audioContext) {
        console.error('‚ùå No audioContext - please click "Start Audio" first');
        alert('Please click "Start Audio" first');
        return;
      }
      
      if (audioContext.state === 'suspended') {
        console.log('‚è∏Ô∏è AudioContext suspended, resuming...');
        await audioContext.resume();
        console.log(`‚úÖ AudioContext resumed, state: ${audioContext.state}`);
      }

      if (currentMode === 'spectral') {
        await startSpectralTX();
      } else {
        await startLegacyTX();
      }
    }

    // ==================== SPECTRAL BEACON TX ====================
    
    async function startSpectralTX() {
      txRunning = true;
      totalDropsScheduled = 0;
      document.getElementById('startTxBtn').disabled = true;
      document.getElementById('stopTxBtn').disabled = false;
      document.getElementById('txStatus').textContent = 'Loading...';
      
      // Get or generate bed
      const fileInput = document.getElementById('bedFile');
      if (fileInput.files.length > 0) {
        const file = fileInput.files[0];
        const arrayBuffer = await file.arrayBuffer();
        bedBuffer = await audioContext.decodeAudioData(arrayBuffer);
      } else {
        bedBuffer = generatePinkNoise(120, audioContext.sampleRate);
      }
      
      // Create source
      bedSource = audioContext.createBufferSource();
      bedSource.buffer = bedBuffer;
      bedSource.loop = true;
      
      // Get parameters - Use UI-controlled gain for testing flexibility
      const centerFreq = parseFloat(document.getElementById('spectralCenterFreq').value);
      const binSpacing = parseFloat(document.getElementById('spectralBinSpacing').value);
      const symbolGain = parseFloat(document.getElementById('spectralGain').value); // Use UI slider
      
      const freqA = centerFreq - binSpacing / 2;
      const freqB = centerFreq + binSpacing / 2;
      
      // Create two narrow peaking filters for bins A and B
      // Q=50 gives ~240Hz bandwidth at 12kHz - optimal balance
      const filterA = audioContext.createBiquadFilter();
      filterA.type = 'peaking';
      filterA.frequency.value = freqA;
      filterA.Q.value = 10; // Wider bandwidth (600Hz) for stronger signal
      filterA.gain.value = 0;
      
      const filterB = audioContext.createBiquadFilter();
      filterB.type = 'peaking';
      filterB.frequency.value = freqB;
      filterB.Q.value = 10; // Wider bandwidth (600Hz) for stronger signal
      filterB.gain.value = 0;
      
      spectralFilters = { binA: filterA, binB: filterB };
      
      // NUCLEAR BOOST: Add high-shelf pre-emphasis at 12-14kHz (+6dB)
      const preEmphasis = audioContext.createBiquadFilter();
      preEmphasis.type = 'highshelf';
      preEmphasis.frequency.value = 13000; // 13kHz shelf
      preEmphasis.gain.value = 6; // +6dB boost above 13kHz
      
      // Connect: source -> preEmphasis -> filterA -> filterB -> masterGain -> destination
      const outputGainDb = parseFloat(document.getElementById('outputGain').value);
      masterGain.gain.value = dbToLinear(outputGainDb);
      
      bedSource.connect(preEmphasis);
      preEmphasis.connect(filterA);
      filterA.connect(filterB);
      filterB.connect(masterGain);
      
      bedSource.start(0);
      
      // DIAGNOSTIC: Add output level meter to verify TX is working
      const outputAnalyser = audioContext.createAnalyser();
      outputAnalyser.fftSize = 256;
      masterGain.connect(outputAnalyser);
      
      // Monitor output level
      const checkOutputLevel = () => {
        if (!txRunning) return;
        const dataArray = new Uint8Array(outputAnalyser.frequencyBinCount);
        outputAnalyser.getByteTimeDomainData(dataArray);
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          const val = (dataArray[i] - 128) / 128;
          sum += val * val;
        }
        const rms = Math.sqrt(sum / dataArray.length);
        const dbFS = 20 * Math.log10(rms || 0.0001);
        console.log(`üîä TX OUTPUT LEVEL: ${dbFS.toFixed(1)} dBFS (should be > -30 dBFS to be audible)`);
        setTimeout(checkOutputLevel, 2000);
      };
      checkOutputLevel();
      
      console.log('‚úÖ SPECTRAL BEACON TX INITIALIZED');
      console.log(`  ‚îú‚îÄ Frequency A: ${freqA}Hz, B: ${freqB}Hz (spacing: ${binSpacing}Hz)`);
      console.log(`  ‚îú‚îÄ Symbol gain: ¬±${symbolGain}dB, Q: 50 (BW ~${(freqA/50).toFixed(0)}Hz)`);
      console.log(`  ‚îú‚îÄ Pre-emphasis: +6dB high-shelf @ 13kHz`);
      console.log(`  ‚îú‚îÄ Output gain: ${outputGainDb}dB (master volume: ${masterGain.gain.value.toFixed(3)})`);
      console.log(`  ‚îú‚îÄ Code length: ${PN31_CODE.length} symbols √ó ${parseInt(document.getElementById('spectralRepeats').value)} repeats`);
      console.log(`  ‚îî‚îÄ Burst every ${parseFloat(document.getElementById('spectralBurstInterval').value)}s`);
      if (symbolGain > 10) {
        console.log(`  ‚ö†Ô∏è  WARNING: Gain >${10}dB may be audible on music`);
      }
      
      document.getElementById('txStatus').textContent = 'Transmitting Spectral Beacon';
      
      // Start symbol transmission
      transmitSpectralSequence();
    }
    
    function transmitSpectralSequence() {
      if (!txRunning || currentMode !== 'spectral') return;
      
      const symbolDurationMs = parseFloat(document.getElementById('spectralSymbolDuration').value);
      const symbolGain = parseFloat(document.getElementById('spectralGain').value); // Use UI slider
      const repeats = parseInt(document.getElementById('spectralRepeats').value);
      const burstIntervalS = parseFloat(document.getElementById('spectralBurstInterval').value);
      
      const symbolDurationS = symbolDurationMs / 1000;
      const fadeTime = 0.01; // 10ms cos¬≤ fade
      const jitterMs = 15; // ¬±15ms jitter
      
      const preambleDurationMs = 90; // 90ms preamble
      const preambleFlipMs = 15; // Flip every 15ms (rapid 01010...)
      
      let phase = 'preamble'; // 'preamble' ‚Üí 'symbols'
      let symbolIndex = 0;
      let preambleFlips = 0;
      const totalSymbols = PN31_CODE.length * repeats;
      const preambleFlipCount = Math.floor(preambleDurationMs / preambleFlipMs);
      
      function transmitNext() {
        if (!txRunning || currentMode !== 'spectral' || !spectralFilters.binA) return;
        
        const now = audioContext.currentTime;
        
        if (phase === 'preamble') {
          // Preamble: rapid alternating A/B flips (010101...)
          const flipValue = (preambleFlips % 2 === 0) ? 1 : -1;
          const gainA = flipValue === 1 ? -symbolGain : symbolGain;
          const gainB = flipValue === 1 ? symbolGain : -symbolGain;
          
          spectralFilters.binA.gain.cancelScheduledValues(now);
          spectralFilters.binB.gain.cancelScheduledValues(now);
          spectralFilters.binA.gain.setValueAtTime(spectralFilters.binA.gain.value, now);
          spectralFilters.binA.gain.linearRampToValueAtTime(gainA, now + fadeTime);
          spectralFilters.binB.gain.setValueAtTime(spectralFilters.binB.gain.value, now);
          spectralFilters.binB.gain.linearRampToValueAtTime(gainB, now + fadeTime);
          
          if (preambleFlips === 0) {
            console.log(`üéµ TX: PREAMBLE START (${preambleDurationMs}ms, ${preambleFlipCount} flips)`);
          }
          
          preambleFlips++;
          
          if (preambleFlips < preambleFlipCount) {
            spectralTransmitTimer = setTimeout(transmitNext, preambleFlipMs);
          } else {
            console.log(`‚úÖ TX: PREAMBLE COMPLETE ‚Üí Starting code transmission`);
            phase = 'symbols';
            spectralTransmitTimer = setTimeout(transmitNext, 20); // Small gap before symbols
          }
        } else {
          // Symbols: PN31 code with differential encoding
          const codeIndex = symbolIndex % PN31_CODE.length;
          const symbol = PN31_CODE[codeIndex];
          
          // Differential encoding: symbol=+1 means B louder, A quieter
          const gainA = symbol === 1 ? -symbolGain : symbolGain;
          const gainB = symbol === 1 ? symbolGain : -symbolGain;
          
          // TX MONITORING: Log actual differential being transmitted
          if (symbolIndex % 10 === 0) {
            console.log(`üì° TX @ symbol ${symbolIndex}: code[${codeIndex}]=${symbol > 0 ? '+1' : '-1'}, gainA=${gainA.toFixed(1)}dB, gainB=${gainB.toFixed(1)}dB, Œî=${(gainB - gainA).toFixed(1)}dB`);
          }
          
          // Smooth crossfade with automation
          spectralFilters.binA.gain.cancelScheduledValues(now);
          spectralFilters.binB.gain.cancelScheduledValues(now);
          spectralFilters.binA.gain.setValueAtTime(spectralFilters.binA.gain.value, now);
          spectralFilters.binA.gain.linearRampToValueAtTime(gainA, now + fadeTime);
          spectralFilters.binB.gain.setValueAtTime(spectralFilters.binB.gain.value, now);
          spectralFilters.binB.gain.linearRampToValueAtTime(gainB, now + fadeTime);
          
          if (symbolIndex % PN31_CODE.length === 0 && symbolIndex > 0) {
            console.log(`üéØ TX: Code repeat ${Math.floor(symbolIndex / PN31_CODE.length) + 1}/${repeats}`);
          }
          
          symbolIndex++;
          
          if (symbolIndex < totalSymbols) {
            // Add jitter to symbol timing
            const jitter = (Math.random() * 2 - 1) * jitterMs;
            spectralTransmitTimer = setTimeout(transmitNext, symbolDurationMs + jitter);
          } else {
            // Burst complete - reset and wait for burstInterval
            console.log(`‚úÖ TX: Burst complete, next burst in ${burstIntervalS}s`);
            spectralTransmitTimer = setTimeout(() => {
              phase = 'preamble';
              symbolIndex = 0;
              preambleFlips = 0;
              transmitNext();
            }, burstIntervalS * 1000);
          }
          
          totalDropsScheduled = Math.floor(symbolIndex / PN31_CODE.length);
          document.getElementById('totalDrops').textContent = totalDropsScheduled;
        }
      }
      
      transmitNext();
    }

    // ==================== LEGACY NOTCH TX ====================
    
    async function startLegacyTX() {
      
      txRunning = true;
      totalDropsScheduled = 0;
      document.getElementById('startTxBtn').disabled = true;
      document.getElementById('stopTxBtn').disabled = false;
      document.getElementById('txStatus').textContent = 'Loading...';
      
      // Get or generate bed
      const fileInput = document.getElementById('bedFile');
      if (fileInput.files.length > 0) {
        const file = fileInput.files[0];
        const arrayBuffer = await file.arrayBuffer();
        bedBuffer = await audioContext.decodeAudioData(arrayBuffer);
      } else {
        // Generate pink noise
        bedBuffer = generatePinkNoise(120, audioContext.sampleRate); // 2 min demo
      }
      
      // Pre-scan for masking if enabled
      const maskingOn = document.getElementById('maskingOn').checked;
      if (maskingOn) {
        document.getElementById('txStatus').textContent = 'Scanning for loud moments...';
        await preScanForMasking(bedBuffer);
      } else {
        candidateFrames = [];
      }
      
      // Set up audio graph: Source -> PeakingEQ -> MasterGain -> destination
      bedSource = audioContext.createBufferSource();
      bedSource.buffer = bedBuffer;
      bedSource.loop = true;
      
      peakingEQ = audioContext.createBiquadFilter();
      peakingEQ.type = 'peaking';
      const dropCenter = parseFloat(document.getElementById('dropCenter').value);
      const dropBw = parseFloat(document.getElementById('dropBw').value);
      peakingEQ.frequency.value = dropCenter;
      peakingEQ.Q.value = dropCenter / dropBw;
      peakingEQ.gain.value = 0; // Start at 0, will modulate
      
      const outputGainDb = parseFloat(document.getElementById('outputGain').value);
      masterGain.gain.value = dbToLinear(outputGainDb);
      
      bedSource.connect(peakingEQ);
      peakingEQ.connect(masterGain);
      
      bedSource.start(0);
      bedSource._startTime = audioContext.currentTime;
      
      // Start real-time gain monitor
      let gainMonitorInterval;
      const startMonitoring = () => {
        gainMonitorInterval = setInterval(() => {
          if (peakingEQ && txRunning) {
            const currentGain = peakingEQ.gain.value;
            const currentTime = audioContext.currentTime;
            // Only log if gain is non-zero (during a drop)
            if (Math.abs(currentGain) > 0.01) {
              console.log(`‚ö° GAIN MONITOR @ t=${currentTime.toFixed(3)}s: ${currentGain.toFixed(3)}dB (linear: ${dbToLinear(currentGain).toFixed(4)})`);
            }
          }
        }, 50); // Check every 50ms
      };
      
      startMonitoring();
      
      // Clean up monitor on stop
      const originalStopTX = stopTX;
      stopTX = function() {
        if (gainMonitorInterval) {
          clearInterval(gainMonitorInterval);
          gainMonitorInterval = null;
        }
        originalStopTX();
      };
      
      const pinkNoiseOnly = document.getElementById('pinkNoiseOnly').checked;
      
      console.log('‚úÖ TX INITIALIZED: Audio context ready, bed buffer loaded');
      console.log(`  ‚îú‚îÄ Sample rate: ${audioContext.sampleRate}Hz`);
      console.log(`  ‚îú‚îÄ Buffer duration: ${bedBuffer.duration.toFixed(1)}s`);
      console.log(`  ‚îú‚îÄ Drop frequency: ${peakingEQ.frequency.value}Hz, Q: ${peakingEQ.Q.value.toFixed(2)}`);
      console.log(`  ‚îî‚îÄ Pink noise mode: ${pinkNoiseOnly ? 'YES (no drops)' : 'NO (drops enabled)'}`);
      
      if (pinkNoiseOnly) {
        document.getElementById('txStatus').textContent = 'Running (Pink Noise Only - No Drops)';
        document.getElementById('nextDropCountdown').textContent = 'N/A (No Drops Mode)';
      } else {
        document.getElementById('txStatus').textContent = 'Running';
        // Schedule drops
        scheduleNextDrop();
        // Update countdown
        updateDropCountdown();
      }
    }

    function scheduleNextDrop() {
      if (!txRunning) return;
      
      const now = audioContext.currentTime;
      const repeatS = parseFloat(document.getElementById('repeatEvery').value);
      const jitterS = parseFloat(document.getElementById('jitter').value);
      const maskingOn = document.getElementById('maskingOn').checked;
      
      let targetTime = now + repeatS + randomJitter(jitterS);
      
      // Find nearest candidate frame if masking ON
      let actualTime = targetTime;
      let maskingRms = null;
      
      // Get drop parameters
      const dropDepth = parseFloat(document.getElementById('dropDepth').value);
      const dropLenMs = parseFloat(document.getElementById('dropLen').value);
      const fadeInMs = parseFloat(document.getElementById('fadeIn').value);
      const fadeOutMs = parseFloat(document.getElementById('fadeOut').value);
      
      const dropLenS = dropLenMs / 1000;
      const fadeInS = fadeInMs / 1000;
      const fadeOutS = fadeOutMs / 1000;
      
      if (maskingOn && candidateFrames.length > 0) {
        const bedStartTime = bedSource._startTime || 0;
        const relativeTarget = targetTime - now + (now - bedStartTime);
        
        // Find nearest candidate frame
        let bestCandidate = null;
        let bestDiff = Infinity;
        const maxSearch = repeatS + jitterS * 2;
        
        for (const frame of candidateFrames) {
          const diff = Math.abs(frame.time - relativeTarget);
          if (diff < bestDiff && frame.time >= relativeTarget && diff < maxSearch) {
            bestDiff = diff;
            bestCandidate = frame;
          }
        }
        
        if (bestCandidate) {
          actualTime = now + (bestCandidate.time - relativeTarget);
          maskingRms = bestCandidate.rms;
          document.getElementById('lastMaskingRms').textContent = maskingRms.toFixed(2) + ' dBFS';
        } else {
          console.warn('No masking candidate found, using target time');
          document.getElementById('lastMaskingRms').textContent = 'No masking found';
        }
      }
      
      nextDropTime = actualTime;
      
      const holdTime = Math.max(0, dropLenS - fadeInS - fadeOutS);
      const gain = peakingEQ.gain;
      
      // Log encoder parameters
      console.log(`üîä ENCODER: Scheduling drop at t=${actualTime.toFixed(3)}s`);
      console.log(`  ‚îú‚îÄ Frequency: ${peakingEQ.frequency.value.toFixed(0)} Hz, Q: ${peakingEQ.Q.value.toFixed(2)}`);
      console.log(`  ‚îú‚îÄ Depth: ${dropDepth.toFixed(2)} dB (linear gain: ${dbToLinear(dropDepth).toFixed(4)})`);
      console.log(`  ‚îú‚îÄ Duration: ${dropLenMs}ms (fadeIn: ${fadeInMs}ms, hold: ${(holdTime*1000).toFixed(0)}ms, fadeOut: ${fadeOutMs}ms)`);
      console.log(`  ‚îî‚îÄ Schedule: start=${actualTime.toFixed(3)}s, peak=${(actualTime + fadeInS).toFixed(3)}s, end=${(actualTime + fadeInS + holdTime + fadeOutS).toFixed(3)}s`);
      
      // Schedule drop
      gain.setValueAtTime(0, actualTime);
      gain.linearRampToValueAtTime(dropDepth, actualTime + fadeInS);
      gain.setValueAtTime(dropDepth, actualTime + fadeInS + holdTime);
      gain.linearRampToValueAtTime(0, actualTime + fadeInS + holdTime + fadeOutS);
      
      console.log(`  ‚úÖ Drop scheduled: ${actualTime.toFixed(3)}s ‚Üí ${(actualTime + fadeInS).toFixed(3)}s [ramp to ${dropDepth}dB] ‚Üí ${(actualTime + fadeInS + holdTime + fadeOutS).toFixed(3)}s [back to 0dB]`);
      
      totalDropsScheduled++;
      document.getElementById('totalDrops').textContent = totalDropsScheduled;
      document.getElementById('lastScheduled').textContent = new Date().toLocaleTimeString();
      
      // Schedule next drop
      const delay = (repeatS + randomJitter(jitterS)) * 1000;
      dropScheduleTimer = setTimeout(() => scheduleNextDrop(), delay);
    }

    function updateDropCountdown() {
      if (!txRunning) return;
      
      if (nextDropTime && audioContext) {
        const remaining = nextDropTime - audioContext.currentTime;
        if (remaining > 0) {
          document.getElementById('nextDropCountdown').textContent = remaining.toFixed(1) + ' s';
        } else {
          document.getElementById('nextDropCountdown').textContent = 'Imminent';
        }
      }
      
      requestAnimationFrame(updateDropCountdown);
    }

    function stopTX() {
      if (!txRunning) return;
      
      txRunning = false;
      
      if (spectralTransmitTimer) {
        clearTimeout(spectralTransmitTimer);
        spectralTransmitTimer = null;
      }
      
      if (dropScheduleTimer) {
        clearTimeout(dropScheduleTimer);
        dropScheduleTimer = null;
      }
      
      if (bedSource) {
        bedSource.stop();
        bedSource.disconnect();
        bedSource = null;
      }
      
      if (spectralFilters.binA) {
        spectralFilters.binA.disconnect();
        spectralFilters.binA = null;
      }
      
      if (spectralFilters.binB) {
        spectralFilters.binB.disconnect();
        spectralFilters.binB = null;
      }
      
      if (peakingEQ) {
        peakingEQ.disconnect();
        peakingEQ = null;
      }
      
      document.getElementById('startTxBtn').disabled = false;
      document.getElementById('stopTxBtn').disabled = true;
      document.getElementById('txStatus').textContent = 'Stopped';
      document.getElementById('nextDropCountdown').textContent = '‚Äî';
    }

    function applySmokeTest() {
      // TX defaults
      document.getElementById('dropCenter').value = 8000;
      document.getElementById('dropBw').value = 600;
      document.getElementById('dropDepth').value = -3.5;
      document.getElementById('dropLen').value = 200;
      document.getElementById('fadeIn').value = 12;
      document.getElementById('fadeOut').value = 12;
      document.getElementById('repeatEvery').value = 10;
      document.getElementById('jitter').value = 2;
      document.getElementById('maskingOn').checked = true;
      document.getElementById('maskWin').value = 50;
      document.getElementById('maskHop').value = 25;
      document.getElementById('maskThreshold').value = -18;
      document.getElementById('outputGain').value = 0;
      
      // RX defaults
      document.getElementById('notchLow').value = 7700;
      document.getElementById('notchHigh').value = 8300;
      document.getElementById('guardLoLow').value = 7000;
      document.getElementById('guardLoHigh').value = 7600;
      document.getElementById('guardHiLow').value = 8400;
      document.getElementById('guardHiHigh').value = 9000;
      document.getElementById('ratioThreshold').value = 1.5;
      document.getElementById('hitsRequired').value = 2;
      document.getElementById('windowS').value = 12;
      document.getElementById('minInterHit').value = 0.5;
      
      alert('Smoke test defaults loaded! Click Start TX to begin.');
    }

    // ==================== RX: LISTENER ====================
    
    async function startRX() {
      if (rxRunning) return;
      
      if (!audioContext) {
        alert('Please click "Start Audio" first');
        return;
      }
      
      if (audioContext.state === 'suspended') {
        await audioContext.resume();
      }
      
      try {
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (e) {
        alert('Microphone access denied: ' + e.message);
        return;
      }

      if (currentMode === 'spectral') {
        await startSpectralRX();
      } else {
        await startLegacyRX();
      }
    }

    // ==================== SPECTRAL BEACON RX ====================
    
    async function startSpectralRX() {
      rxRunning = true;
      document.getElementById('startRxBtn').disabled = true;
      document.getElementById('stopRxBtn').disabled = false;
      document.getElementById('recalibrateBtn').disabled = false;
      
      // Set up mic pipeline
      micSource = audioContext.createMediaStreamSource(micStream);
      
      const hpf = audioContext.createBiquadFilter();
      hpf.type = 'highpass';
      hpf.frequency.value = 200;
      
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 2048; // 2048 @ 48kHz = ~43Hz bins, ~21ms hop
      analyser.smoothingTimeConstant = 0.3; // Moderate smoothing
      
      micSource.connect(hpf);
      hpf.connect(analyser);
      
      // Reset FSM state
      fsmState = 'IDLE';
      fsmStateStartTime = audioContext.currentTime;
      fsmLockoutUntil = 0;
      spectralSymbolBuffer = [];
      spectralCorrelationHistory = [];
      preambleFlipHistory = [];
      codeDetectionAttempts = [];
      codeRepeatTimestamps = [];
      presenceVerified = false;
      spectralBroadbandEMA = -100;
      spectralConsecutiveHits = 0;
      
      // Reset baseline calibration
      baselineCalibrated = false;
      baselineCalibrationSamples = [];
      baselineEnergySum = -100;
      baselineGuardLo = -100;
      baselineGuardHi = -100;
      
      // Reset guard EMA tracking for temporal smoothing
      window.guardLoEMA = -100;
      window.guardHiEMA = -100;
      
      // Update UI
      document.getElementById('baselineStatus').textContent = 'Calibrating baseline (5 sec)...';
      document.getElementById('baselineNoise').textContent = 'Measuring...';
      document.getElementById('detectionThreshold').textContent = 'Computing...';
      updateFSMStateDisplay();
      
      console.log('‚úÖ SPECTRAL BEACON RX INITIALIZED - CALIBRATING BASELINE...');
      console.log(`  ‚îú‚îÄ FFT size: ${analyser.fftSize}`);
      console.log(`  ‚îî‚îÄ Calibrating noise baseline for 5 seconds before detection...`);
      
      // Start detection loop
      const symbolDurationMs = parseFloat(document.getElementById('spectralSymbolDuration').value);
      rxInterval = setInterval(detectSpectralSymbol, symbolDurationMs);
    }
    
    function detectSpectralSymbol() {
      // Debug: ALWAYS log if not running so user knows
      if (!rxRunning) {
        if (Math.random() < 0.05) console.warn('‚ö†Ô∏è RX NOT RUNNING - Click "Start RX" to detect signals');
        return;
      }
      if (!analyser) {
        if (Math.random() < 0.05) console.warn('‚ö†Ô∏è RX: analyser not initialized');
        return;
      }
      if (currentMode !== 'spectral') {
        if (Math.random() < 0.05) console.warn(`‚ö†Ô∏è RX: wrong mode (${currentMode}, expected spectral)`);
        return;
      }
      
      // Initialize frame counter for aggressive diagnostics
      if (!window.rxDiagnosticFrameCount) window.rxDiagnosticFrameCount = 0;
      window.rxDiagnosticFrameCount++;
      const frameNum = window.rxDiagnosticFrameCount;
      
      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Float32Array(bufferLength);
      analyser.getFloatFrequencyData(dataArray);
      
      const sampleRate = audioContext.sampleRate;
      const binHz = (sampleRate / 2) / (bufferLength - 1);
      
      // DIAGNOSTIC: Log FFT data statistics for first 100 frames
      if (frameNum <= 100) {
        const validData = Array.from(dataArray).filter(v => isFinite(v));
        const min = validData.length > 0 ? Math.min(...validData) : -200;
        const max = validData.length > 0 ? Math.max(...validData) : -200;
        const mean = validData.length > 0 ? validData.reduce((a,b) => a+b, 0) / validData.length : -200;
        console.log(`üîç RX DIAGNOSTIC Frame ${frameNum} @ t=${audioContext.currentTime.toFixed(2)}s:`);
        console.log(`  ‚îú‚îÄ FFT Stats: min=${min.toFixed(1)}dB, max=${max.toFixed(1)}dB, mean=${mean.toFixed(1)}dB`);
        console.log(`  ‚îî‚îÄ Audio input ${mean > -80 ? '‚úÖ ACTIVE' : '‚ùå TOO QUIET - CHECK MIC'}`);
      }
      
      // Get parameters
      const centerFreq = parseFloat(document.getElementById('spectralCenterFreq').value);
      const binSpacing = parseFloat(document.getElementById('spectralBinSpacing').value);
      
      const freqA = centerFreq - binSpacing / 2;
      const freqB = centerFreq + binSpacing / 2;
      
      // DIAGNOSTIC: Calculate FFT bin indices
      const binIndexA = Math.round(freqA / binHz);
      const binIndexB = Math.round(freqB / binHz);
      
      // Extract power at bins A and B - measure ¬±1 bin around each center
      const powerA = computeBandPower(dataArray, binHz, freqA - binHz, freqA + binHz);
      const powerB = computeBandPower(dataArray, binHz, freqB - binHz, freqB + binHz);
      
      // DIAGNOSTIC: Show real-time FFT visualization for first 100 frames
      if (frameNum <= 100) {
        const getContext = (idx) => {
          const safeVal = (v) => (v != null && isFinite(v)) ? v.toFixed(1) : '-200.0';
          const before = [dataArray[idx-2], dataArray[idx-1]].map(safeVal);
          const center = safeVal(dataArray[idx]);
          const after = [dataArray[idx+1], dataArray[idx+2]].map(safeVal);
          return `[${before.join(',')},(${center}),${after.join(',')}]`;
        };
        console.log(`  ‚îú‚îÄ Bin A [${binIndexA}] @ ${freqA}Hz: ${getContext(binIndexA)} dB`);
        console.log(`  ‚îú‚îÄ Bin B [${binIndexB}] @ ${freqB}Hz: ${getContext(binIndexB)} dB`);
        console.log(`  ‚îú‚îÄ PowerA: ${powerA.toFixed(2)}dB, PowerB: ${powerB.toFixed(2)}dB`);
        console.log(`  ‚îî‚îÄ Œî (B-A): ${(powerB - powerA).toFixed(2)}dB`);
      }
      
      // Guards (for baseline stability check) - placed ¬±3√ó bin spacing for better isolation
      const guardLoFreq = freqA - 3 * binSpacing;
      const guardHiFreq = freqB + 3 * binSpacing;
      const powerGuardLoRaw = computeBandPower(dataArray, binHz, guardLoFreq - binHz, guardLoFreq + binHz);
      const powerGuardHiRaw = computeBandPower(dataArray, binHz, guardHiFreq - binHz, guardHiFreq + binHz);
      
      // Apply temporal smoothing to guards (EMA with ~300ms time constant)
      const guardAlpha = 0.2; // Slower than broadband to reduce noise sensitivity
      if (!window.guardLoEMA || window.guardLoEMA < -90) window.guardLoEMA = powerGuardLoRaw;
      if (!window.guardHiEMA || window.guardHiEMA < -90) window.guardHiEMA = powerGuardHiRaw;
      window.guardLoEMA = window.guardLoEMA * (1 - guardAlpha) + powerGuardLoRaw * guardAlpha;
      window.guardHiEMA = window.guardHiEMA * (1 - guardAlpha) + powerGuardHiRaw * guardAlpha;
      const powerGuardLo = window.guardLoEMA;
      const powerGuardHi = window.guardHiEMA;
      
      // Compute differential (in dB)
      const delta = powerB - powerA;
      
      // Compute broadband RMS for loudness veto (1-15kHz)
      const broadbandPower = computeBandPower(dataArray, binHz, 1000, 15000);
      
      // Update broadband EMA (200ms time constant at 60ms symbol rate)
      const alpha = 0.3; // ~200ms EMA
      spectralBroadbandEMA = spectralBroadbandEMA * (1 - alpha) + broadbandPower * alpha;
      
      // Loudness veto: DISABLED (was blocking too many valid frames)
      const loudnessVeto = false; // (broadbandPower - spectralBroadbandEMA > 18);
      
      // Update display
      document.getElementById('loudnessLevel').textContent = broadbandPower.toFixed(1) + ' dB';
      
      // Add delta to buffer (always, even during calibration)
      spectralSymbolBuffer.push(delta);
      
      // Keep buffer at code length
      const codeLen = PN31_CODE.length;
      if (spectralSymbolBuffer.length > codeLen * 2) {
        spectralSymbolBuffer.shift();
      }
      
      // BASELINE CALIBRATION PHASE - Collect correlation samples to establish noise floor
      if (!baselineCalibrated) {
        // Initialize collection arrays
        if (!window.baselineEnergySamples) window.baselineEnergySamples = [];
        if (!window.baselineGuardLoSamples) window.baselineGuardLoSamples = [];
        if (!window.baselineGuardHiSamples) window.baselineGuardHiSamples = [];
        if (!window.baselineDeltaSamples) window.baselineDeltaSamples = [];
        if (!window.baselineCorrelationSamples) window.baselineCorrelationSamples = [];
        
        const currentEnergySum = linearToDb(powerA + powerB);
        window.baselineEnergySamples.push(currentEnergySum);
        window.baselineGuardLoSamples.push(powerGuardLo);
        window.baselineGuardHiSamples.push(powerGuardHi);
        window.baselineDeltaSamples.push(delta); // Keep signed deltas for proper correlation
        baselineBroadbandSamples.push(broadbandPower);
        
        // Compute correlation on recent buffer for baseline (once we have enough samples)
        if (spectralSymbolBuffer.length >= PN31_CODE.length) {
          const recentSeg = spectralSymbolBuffer.slice(-PN31_CODE.length);
          const corrPos = computeCorrelation(recentSeg, PN31_CODE);
          const corrNeg = computeCorrelation(recentSeg, PN31_CODE.map(v => -v));
          const corrPeak = Math.max(corrPos, corrNeg);
          window.baselineCorrelationSamples.push(corrPeak);
        }
        
        // DIAGNOSTIC: Log every calibration sample
        const calSampleCount = window.baselineDeltaSamples.length;
        console.log(`üìä CALIBRATION Sample ${calSampleCount}/70: delta=${delta.toFixed(2)}dB, |delta|=${Math.abs(delta).toFixed(2)}dB, broadband=${broadbandPower.toFixed(1)}dB`);
        
        if (calSampleCount >= 70) {
          // Compute baseline statistics from correlation samples (noise floor)
          if (window.baselineCorrelationSamples.length > 0) {
            baselineCorrelationMean = window.baselineCorrelationSamples.reduce((a,b) => a+b, 0) / window.baselineCorrelationSamples.length;
            const variance = window.baselineCorrelationSamples.reduce((a,b) => a + Math.pow(b - baselineCorrelationMean, 2), 0) / window.baselineCorrelationSamples.length;
            baselineCorrelationStdDev = Math.max(Math.sqrt(variance), 0.01);
          } else {
            // Fallback if not enough correlation samples
            baselineCorrelationMean = 0.05;
            baselineCorrelationStdDev = 0.02;
          }
          
          // Compute broadband baseline statistics
          baselineBroadbandMean = baselineBroadbandSamples.reduce((a,b) => a+b, 0) / baselineBroadbandSamples.length;
          const bbVar = baselineBroadbandSamples.reduce((a,b) => a + Math.pow(b - baselineBroadbandMean, 2), 0) / baselineBroadbandSamples.length;
          baselineBroadbandStdDev = Math.max(Math.sqrt(bbVar), 0.5);
          
          // Compute energy and guard baselines
          baselineEnergySum = window.baselineEnergySamples.reduce((a,b) => a+b, 0) / window.baselineEnergySamples.length;
          baselineGuardLo = window.baselineGuardLoSamples.reduce((a,b) => a+b, 0) / window.baselineGuardLoSamples.length;
          baselineGuardHi = window.baselineGuardHiSamples.reduce((a,b) => a+b, 0) / window.baselineGuardHiSamples.length;
          
          // VALIDATION: Check if calibration makes sense
          if (baselineCorrelationMean > 0.5) {
            console.error('‚ö†Ô∏è CALIBRATION WARNING: Baseline correlation suspiciously high!');
            console.error('  ‚îú‚îÄ Measured baseline: ' + baselineCorrelationMean.toFixed(3));
            console.error('  ‚îî‚îÄ TX may have been running during calibration - proceeding anyway');
          }
          
          baselineCalibrated = true;
          
          // Compute thresholds based on observed delta magnitudes
          const deltaMags = window.baselineDeltaSamples.map(d => Math.abs(d));
          const avgDeltaMag = deltaMags.reduce((a,b) => a+b, 0) / deltaMags.length;
          const detectionThreshold = Math.max(avgDeltaMag * 3, 2.0); // 3√ó baseline or 2dB minimum
          
          document.getElementById('baselineStatus').textContent = '‚úÖ Calibrated - Ready';
          document.getElementById('baselineNoise').textContent = `Corr: Œº=${baselineCorrelationMean.toFixed(3)}, œÉ=${baselineCorrelationStdDev.toFixed(3)}`;
          document.getElementById('detectionThreshold').textContent = `|Œî| > ${detectionThreshold.toFixed(1)}dB`;
          
          console.log('üéØ BASELINE CALIBRATION COMPLETE:');
          console.log(`  ‚îú‚îÄ Correlation baseline: Œº=${baselineCorrelationMean.toFixed(3)}, œÉ=${baselineCorrelationStdDev.toFixed(3)}`);
          console.log(`  ‚îú‚îÄ Avg |Œî| in noise: ${avgDeltaMag.toFixed(2)}dB ‚Üí Detection threshold: ${detectionThreshold.toFixed(1)}dB`);
          console.log(`  ‚îú‚îÄ Broadband: Œº=${baselineBroadbandMean.toFixed(1)}dB, œÉ=${baselineBroadbandStdDev.toFixed(1)}dB`);
          console.log(`  ‚îú‚îÄ Energy sum: ${baselineEnergySum.toFixed(1)}dB`);
          console.log(`  ‚îú‚îÄ Guards: Lo=${baselineGuardLo.toFixed(1)}dB, Hi=${baselineGuardHi.toFixed(1)}dB`);
          console.log(`  ‚îî‚îÄ FSM ready - listening for encoded signal...`);
          
          // AUTO-START TX: DISABLED for manual testing
          console.log('‚ÑπÔ∏è Auto-start TX disabled - use "Start TX" button manually');
          // Uncomment below to re-enable auto-start after calibration:
          /*
          if (!txRunning) {
            setTimeout(() => {
              console.log('‚è∞ Auto-start timeout fired - calling startTX()...');
              try {
                startTX();
                console.log('‚úÖ TX AUTO-STARTED - Now testing with encoded audio');
              } catch (error) {
                console.error('‚ùå Auto-start failed:', error);
              }
            }, 500);
          }
          */
        } else {
          // Update UI during calibration
          document.getElementById('baselineStatus').textContent = `Calibrating... ${calSampleCount}/70`;
          
          // Log progress every 10 frames
          if (calSampleCount % 10 === 0) {
            console.log(`üìä CALIBRATION PROGRESS: ${calSampleCount}/70 samples collected`);
          }
        }
        
        // Update UI during calibration
        document.getElementById('corrPeak').textContent = `${Math.abs(delta).toFixed(2)}dB (cal)`;
        document.getElementById('corrZScore').textContent = `${calSampleCount}/70`;
        document.getElementById('corrPSR').textContent = '‚Äî';
        return; // Don't detect during calibration
      }
      
      // Detailed logging every 20 frames (~1.2s at 60ms symbols)
      const frameCount = spectralSymbolBuffer.length;
      if (frameCount % 20 === 0 && frameCount > 0) {
        console.log(`üéØ SPECTRAL RX @ frame ${frameCount}:`);
        console.log(`  ‚îú‚îÄ BinHz: ${binHz.toFixed(2)}Hz, FreqA: ${freqA}Hz, FreqB: ${freqB}Hz`);
        console.log(`  ‚îú‚îÄ PowerA: ${powerA.toFixed(2)}dB, PowerB: ${powerB.toFixed(2)}dB, Œî: ${delta.toFixed(2)}dB`);
        console.log(`  ‚îú‚îÄ Broadband: ${broadbandPower.toFixed(2)}dB, EMA: ${spectralBroadbandEMA.toFixed(2)}dB, Veto: ${loudnessVeto}`);
        console.log(`  ‚îî‚îÄ Buffer size: ${spectralSymbolBuffer.length}/${PN31_CODE.length}`);
      }
      
      if (!loudnessVeto) {
        // Try correlation when we have enough symbols
        if (spectralSymbolBuffer.length >= codeLen) {
          // Phase scan and polarity check
          const phaseMax = 7; // Check 8 phase offsets (better tolerance to jitter)
          let best = { corr: -1, phase: 0, sign: 1 };
          let allCorrelations = []; // For PSR calculation
          
          // DIAGNOSTIC: Log buffer state periodically
          if (frameNum % 60 === 0 && spectralSymbolBuffer.length >= codeLen) {
            console.log(`üî¨ CORRELATION DEBUG @ frame ${frameNum}:`);
            console.log(`  ‚îú‚îÄ Buffer length: ${spectralSymbolBuffer.length}`);
            console.log(`  ‚îú‚îÄ Last 10 deltas: [${spectralSymbolBuffer.slice(-10).map(d => d.toFixed(1)).join(', ')}]`);
            console.log(`  ‚îú‚îÄ Expected code:  [${PN31_CODE.slice(0, 10).map(v => (v > 0 ? '+' : '-') + Math.abs(v)).join(', ')}]`);
            console.log(`  ‚îî‚îÄ Sign pattern: ${spectralSymbolBuffer.slice(-10).map(d => d > 0 ? '+' : '-').join('')} vs ${PN31_CODE.slice(0, 10).map(v => v > 0 ? '+' : '-').join('')}`);
          }
          
          for (let p = 0; p <= phaseMax; p++) {
            const start = spectralSymbolBuffer.length - codeLen - p;
            if (start >= 0) {
              const seg = spectralSymbolBuffer.slice(start, start + codeLen);
              const corrPos = computeCorrelation(seg, PN31_CODE);
              const corrNeg = computeCorrelation(seg, PN31_CODE.map(v => -v));
              const corr = Math.max(corrPos, corrNeg);
              const sign = corrNeg > corrPos ? -1 : 1;
              allCorrelations.push(corr);
              if (corr > best.corr) best = { corr, phase: p, sign };
              
              // DIAGNOSTIC: Log correlation details for best phase
              if (frameNum % 120 === 0 && p === 0) {
                console.log(`  ‚îú‚îÄ Phase ${p}: corrPos=${corrPos.toFixed(3)}, corrNeg=${corrNeg.toFixed(3)}, best=${corr.toFixed(3)} (sign=${sign > 0 ? '+' : '-'})`);
              }
            }
          }
          const correlation = best.corr;
          
          // Compute Peak-to-Sidelobe Ratio (PSR)
          // Sidelobe = mean of all non-peak correlations
          const sidelobes = allCorrelations.filter((c, i) => i !== best.phase);
          const sidelobeMean = sidelobes.length > 0 ? sidelobes.reduce((a,b) => a+b, 0) / sidelobes.length : 0;
          const peakToSidelobeRatio = correlation > 0 && sidelobeMean > 0 ? 
            20 * Math.log10(correlation / Math.max(sidelobeMean, 0.001)) : 0;
          
          // NORMAL DETECTION (after calibration)
          // Compute Z-score using baseline stats
          const zScore = baselineCorrelationStdDev > 1e-6 ? 
            (correlation - baselineCorrelationMean) / baselineCorrelationStdDev : 0;
          
          // Update display (with null checks)
          const corrPeakEl = document.getElementById('corrPeak');
          const corrZScoreEl = document.getElementById('corrZScore');
          const corrPSREl = document.getElementById('corrPSR');
          if (corrPeakEl) corrPeakEl.textContent = correlation.toFixed(3);
          if (corrZScoreEl) corrZScoreEl.textContent = zScore.toFixed(2);
          if (corrPSREl) corrPSREl.textContent = peakToSidelobeRatio.toFixed(1);
          
          // Log RX activity with detailed metrics
          if (frameCount % 60 === 0 && frameCount > 0) {
            console.log(`üéß RX ACTIVE @ frame ${frameCount}:`);
            console.log(`  ‚îú‚îÄ Correlation: ${correlation.toFixed(3)} (threshold: ‚â•${0.25})`);
            console.log(`  ‚îú‚îÄ Z-score: ${zScore.toFixed(2)} (threshold: ‚â•${2.5})`);
            console.log(`  ‚îú‚îÄ PSR: ${peakToSidelobeRatio.toFixed(1)}dB (threshold: ‚â•${5.0}dB)`);
            console.log(`  ‚îú‚îÄ Recent Œî: [${spectralSymbolBuffer.slice(-8).map(d => d.toFixed(1)).join(', ')}] dB`);
            console.log(`  ‚îî‚îÄ FSM state: ${fsmState}`);
          }
          
          // Log correlation periodically
          if (frameCount % 30 === 0 && frameCount > 0) {
            console.log(`üìä CORRELATION COMPUTED:`);
            console.log(`  ‚îú‚îÄ Peak: ${correlation.toFixed(3)} (phase=${best.phase}, sign=${best.sign > 0 ? '+' : '-'})`);
            console.log(`  ‚îú‚îÄ Z-score: ${zScore.toFixed(2)} (baseline: Œº=${baselineCorrelationMean.toFixed(3)}, œÉ=${baselineCorrelationStdDev.toFixed(3)})`);
            console.log(`  ‚îú‚îÄ PSR: ${peakToSidelobeRatio.toFixed(1)} dB`);
            console.log(`  ‚îî‚îÄ Delta (last 8): [${spectralSymbolBuffer.slice(-8).map(d => d.toFixed(1)).join(', ')}]`);
          }
          
          // ========== FSM STATE MACHINE ==========
          const now = audioContext.currentTime;
          
          // Check lockout (45s cooldown after UNLOCKED)
          if (fsmLockoutUntil > now) {
            if (frameCount % 120 === 0) {
              const remaining = (fsmLockoutUntil - now).toFixed(1);
              console.log(`üîí LOCKOUT ACTIVE: ${remaining}s remaining (no triggers until cooldown expires)`);
            }
            return;
          }
          
          // FSM thresholds - adjust for iPhone Mode (over-air detection)
          const isIphoneMode = document.getElementById('iphoneMode')?.checked || false;
          // IRONCLAD: Raised thresholds + enforcing sign-match (no bypass)
          const CORR_THRESHOLD = isIphoneMode ? 0.15 : 0.50; // Raised to 0.50 to block ambient noise (noise: 0.422, encoded: >0.58)
          const PSR_THRESHOLD = isIphoneMode ? 5.0 : 8.0; // Keep at 8.0
          const Z_THRESHOLD = isIphoneMode ? 2.2 : 5.0; // Raised to 5.0 to block ambient noise (noise: 4.06, encoded: >5.0)
          const SIGN_MATCH_THRESHOLD = 0.75; // Raised to 0.75 to block ambient noise (noise: 0.742, encoded @60dB: >0.80)
          const REQUIRED_VOTES = isIphoneMode ? 3 : 3; // Keep at 3 votes always
          const MEDIAN_DELTA_THRESHOLD = 0.5; // dB - keep same
          const ENERGY_BALANCE_THRESHOLD = 5.0; // dB - much more lenient for acoustic coupling
          const GUARD_THRESHOLD = 20.0; // dB - more lenient (acoustic path adds noise)
          // NEW: Maximum signal amplitude threshold - rejects overly loud signals (likely unencoded audio too close)
          const MAX_SIGNAL_AMPLITUDE_DB = isIphoneMode ? 75.0 : 85.0; // dB - reject if signal sum > this
          const CADENCE_WINDOW_MS = 0; // unused (dynamic cadence below)
          const PREAMBLE_TIMEOUT = 3.0; // seconds - more time for weak signals
          const VOTE_WINDOW = 8.0; // seconds - longer window for weak signals
          const COOLDOWN_DURATION = 45.0; // seconds
          
          // ===== STATE: IDLE =====
          if (fsmState === 'IDLE') {
            // BALANCED TRIGGER: Require decent correlation OR good PSR (not both)
            const triggerCorr = correlation >= CORR_THRESHOLD * 0.7; // 70% of threshold
            const triggerPSR = peakToSidelobeRatio >= PSR_THRESHOLD * 0.6; // 60% of PSR threshold
            
            if (triggerCorr || triggerPSR) { // Either one can trigger (not both required)
              fsmState = 'CODE_LOCK';
              fsmStateStartTime = now;
              codeDetectionAttempts = [];
              codeRepeatTimestamps = [];
              window.detectionPolarities = [];
              window.detectionHistory = [];
              
              console.log(`üéµ FSM: IDLE ‚Üí CODE_LOCK`);
              console.log(`  ‚îú‚îÄ Trigger: corr=${correlation.toFixed(3)} (‚â•${(CORR_THRESHOLD*0.7).toFixed(3)}), psr=${peakToSidelobeRatio.toFixed(1)}dB (‚â•${(PSR_THRESHOLD*0.6).toFixed(1)}dB)`);
              console.log(`  ‚îî‚îÄ Required for unlock: ${REQUIRED_VOTES} detections with proper cadence`);
              updateFSMStateDisplay();
            }
            
            // Log IDLE state periodically to show we're alive
            if (frameCount % 180 === 0) {
              console.log(`‚è≥ FSM: IDLE (waiting for signal... corr=${correlation.toFixed(3)}, psr=${peakToSidelobeRatio.toFixed(1)}dB, z=${zScore.toFixed(2)})`);
            }
          }
          
          // ===== STATE: PREAMBLE_LOCK ===== (UNUSED - keeping for backward compat)
          else if (fsmState === 'PREAMBLE_LOCK') {
            // Auto-transition to CODE_LOCK
            console.log(`‚úÖ FSM: PREAMBLE_LOCK ‚Üí CODE_LOCK (auto-skip)`);
            fsmState = 'CODE_LOCK';
            fsmStateStartTime = now;
            codeDetectionAttempts = [];
            codeRepeatTimestamps = [];
            updateFSMStateDisplay();
          }
          
          // ===== STATE: CODE_LOCK =====
          else if (fsmState === 'CODE_LOCK') {
            const elapsed = now - fsmStateStartTime;
            
            if (elapsed > VOTE_WINDOW) {
              // Timeout - back to IDLE
              console.log(`‚è±Ô∏è FSM: CODE_LOCK ‚Üí IDLE (timeout after ${elapsed.toFixed(1)}s, no valid code detected)`);
              fsmState = 'IDLE';
              fsmStateStartTime = now;
              updateFSMStateDisplay();
              return;
            }
            
            // Compute all detection metrics
            // Use phase-aligned deltas (align with best.phase found by correlation)
            const recentDeltas = spectralSymbolBuffer.slice(
              spectralSymbolBuffer.length - codeLen - best.phase,
              spectralSymbolBuffer.length - best.phase
            );
            
            // 0. Signal amplitude check (NEW) - reject overly loud signals (likely unencoded audio too close)
            const signalAmplitudeDb = Math.max(linearToDb(powerA), linearToDb(powerB));
            const amplitudePass = signalAmplitudeDb <= MAX_SIGNAL_AMPLITUDE_DB;
            
            // 0b. LAYER 1: SIGN PATTERN MATCHING (MOST CRITICAL - binary check)
            // Count how many symbols have correct polarity matching PN31 code
            // Account for polarity inversion detected by correlation (best.sign)
            let signMatches = 0;
            for (let i = 0; i < Math.min(recentDeltas.length, PN31_CODE.length); i++) {
              const expectedSign = (PN31_CODE[i] > 0 ? 1 : -1) * best.sign; // Apply polarity correction
              const actualSign = recentDeltas[i] > 0 ? 1 : -1;
              if (expectedSign === actualSign) signMatches++;
            }
            const signMatchRatio = recentDeltas.length > 0 ? signMatches / Math.min(recentDeltas.length, PN31_CODE.length) : 0;
            const isOverAirMode = document.getElementById('overAirMode')?.checked || false;
            // IRONCLAD: sign-match ALWAYS enforced (no bypass)
            const signMatchPass = signMatchRatio >= SIGN_MATCH_THRESHOLD;
            
            // 1. Correlation check
            const corrPass = correlation >= CORR_THRESHOLD;
            
            // 2. PSR check
            const psrPass = peakToSidelobeRatio >= PSR_THRESHOLD;
            
            // 3. Z-score check
            const zPass = zScore >= Z_THRESHOLD;
            
            // 4. Median |Œî| check
            const deltaAbs = recentDeltas.map(d => Math.abs(d));
            const medianDelta = deltaAbs.length > 0 
              ? deltaAbs.sort((a,b) => a-b)[Math.floor(deltaAbs.length/2)]
              : 0;
            const medianDeltaPass = medianDelta >= MEDIAN_DELTA_THRESHOLD;
            
            // 5. Energy balance check: |(E(A)+E(B)) - baseline| ‚â§ 1.0 dB
            const currentEnergySum = linearToDb(powerA + powerB);
            const energyDeviation = Math.abs(currentEnergySum - baselineEnergySum);
            const energyBalancePass = energyDeviation <= ENERGY_BALANCE_THRESHOLD;
            
            // 6. Guard stability check
            const guardLoDeviation = Math.abs(powerGuardLo - baselineGuardLo);
            const guardHiDeviation = Math.abs(powerGuardHi - baselineGuardHi);
            const guardsPass = guardLoDeviation <= GUARD_THRESHOLD && guardHiDeviation <= GUARD_THRESHOLD;
            
            // Log ALL candidates to diagnose why unlock isn't happening
            if (correlation > 0.15 || zScore > 1.5) {
              console.log(`üîç CODE_LOCK CANDIDATE @ t=${elapsed.toFixed(2)}s:`);
              console.log(`  ‚îú‚îÄ [amplitude] ${signalAmplitudeDb.toFixed(1)}dB (‚â§${MAX_SIGNAL_AMPLITUDE_DB}) ${amplitudePass?'‚úÖ':'‚ùå'}`);
              console.log(`  ‚îú‚îÄ [sign-match] ${signMatchRatio.toFixed(3)} = ${signMatches}/${Math.min(recentDeltas.length, PN31_CODE.length)} (‚â•${SIGN_MATCH_THRESHOLD.toFixed(2)}) ${signMatchPass?'‚úÖ':'‚ùå'}`);
              // DIAGNOSTIC: Show actual vs expected signs
              const actualSigns = recentDeltas.slice(0, 31).map(d => d > 0 ? '+' : '-').join('');
              const expectedSigns = PN31_CODE.map(v => ((v > 0 ? 1 : -1) * best.sign > 0) ? '+' : '-').join('');
              console.log(`  ‚îú‚îÄ [sign-pattern] actual:   ${actualSigns}`);
              console.log(`  ‚îú‚îÄ [sign-pattern] expected: ${expectedSigns}`);
              console.log(`  ‚îú‚îÄ [phase-info] best.phase=${best.phase}, best.sign=${best.sign}, bufLen=${spectralSymbolBuffer.length}`);
              console.log(`  ‚îú‚îÄ [correlation] ${correlation.toFixed(3)} (‚â•${CORR_THRESHOLD}) ${corrPass?'‚úÖ':'‚ùå'}`);
              console.log(`  ‚îú‚îÄ [PSR] ${peakToSidelobeRatio.toFixed(1)}dB (‚â•${PSR_THRESHOLD}) ${psrPass?'‚úÖ':'‚ùå'}`);
              console.log(`  ‚îú‚îÄ [Z-score] ${zScore.toFixed(2)} (‚â•${Z_THRESHOLD}) ${zPass?'‚úÖ':'‚ùå'}`);
              console.log(`  ‚îú‚îÄ [median|Œî|] ${medianDelta.toFixed(2)}dB (‚â•${MEDIAN_DELTA_THRESHOLD}) ${medianDeltaPass?'‚úÖ':'‚ùå'}`);
              console.log(`  ‚îú‚îÄ [energy] dev=${energyDeviation.toFixed(1)}dB (‚â§${ENERGY_BALANCE_THRESHOLD}) ${energyBalancePass?'‚úÖ':'‚ùå'}`);
              console.log(`  ‚îî‚îÄ [guards] Lo=${guardLoDeviation.toFixed(1)}dB, Hi=${guardHiDeviation.toFixed(1)}dB (‚â§${GUARD_THRESHOLD}) ${guardsPass?'‚úÖ':'‚ùå'}`);
            }
            
            // PROGRESSIVE VALIDATION (get unlock working, then tighten)
            
            // Layer 0: AMPLITUDE CHECK (NEW) - reject overly loud signals first
            if (!amplitudePass) {
              console.log(`  ‚îî‚îÄ ‚ùå Signal too loud: ${signalAmplitudeDb.toFixed(1)}dB > ${MAX_SIGNAL_AMPLITUDE_DB}dB (likely unencoded audio too close)`);
              return; // Reject immediately
            }
            
            // Layer 1: CORE CRITERIA - IRONCLAD: sign-match ALWAYS ENFORCED (no bypass)
            const corePass = corrPass && psrPass && zPass && signMatchPass;
            
            // Layer 2: TX STATUS CHECK (warn but don't block)
            if (!txRunning && !isOverAirMode && frameCount % 60 === 0) {
              console.log(`  ‚îî‚îÄ ‚ö†Ô∏è WARNING: TX not running - unlock may be from noise!`);
            }
            if (isOverAirMode && frameCount % 120 === 0) {
              console.log(`  ‚îî‚îÄ ‚ÑπÔ∏è Over-Air Mode enabled - bypassing local TX validation`);
            }

            // Layer 3: POLARITY TRACKING (for diagnostics, not blocking)
            if (!window.detectionPolarities) window.detectionPolarities = [];
            const detectionPolarity = best.sign; // +1 or -1 from correlation
            
            // Layer 4: MEDIAN DELTA VALIDATION - Relaxed threshold
            const medianDeltaValidation = medianDelta >= MEDIAN_DELTA_THRESHOLD; // Back to normal
            
            // Additional rejection messages for failed core criteria
            if (!corePass) {
              const failures = [];
              if (isIphoneMode && !signMatchPass) failures.push(`Sign-match too low: ${signMatchRatio.toFixed(3)} (${signMatches}/${Math.min(recentDeltas.length, PN31_CODE.length)}) < ${SIGN_MATCH_THRESHOLD.toFixed(2)}`);
              if (!corrPass) failures.push(`Correlation too low: ${correlation.toFixed(3)} < ${CORR_THRESHOLD}`);
              if (!psrPass) failures.push(`PSR too low: ${peakToSidelobeRatio.toFixed(1)}dB < ${PSR_THRESHOLD}dB`);
              if (!zPass) failures.push(`Z-score too low: ${zScore.toFixed(2)} < ${Z_THRESHOLD}`);
              if (isIphoneMode && !guardsPass) failures.push(`Guards unstable: Lo=${guardLoDeviation.toFixed(1)}dB, Hi=${guardHiDeviation.toFixed(1)}dB > ${GUARD_THRESHOLD}dB`);
              console.log(`  ‚îî‚îÄ ‚ùå ${failures.join(', ')}`);
              return;
            }
            
            if (corePass && medianDeltaValidation) {
              // Store detection with metadata
              const detection = {
                time: now,
                correlation: correlation,
                polarity: detectionPolarity,
                psr: peakToSidelobeRatio,
                zScore: zScore,
                medianDelta: medianDelta,
                txWasRunning: txRunning
              };
              
              if (!window.detectionHistory) window.detectionHistory = [];
              window.detectionHistory.push(detection);
              
              // Keep only recent history (last 10 seconds)
              window.detectionHistory = window.detectionHistory.filter(d => now - d.time < 10);
              
              codeRepeatTimestamps.push(now);
              window.detectionPolarities.push(detectionPolarity);
              
              console.log(`  ‚úÖ VALID DETECTION! Vote ${codeRepeatTimestamps.length}/2 (polarity: ${detectionPolarity > 0 ? '+' : '-'}, TX: ${txRunning ? 'ON' : 'OFF'})`);
              
              // Layer 5: REQUIRE N DETECTIONS with proper cadence (adaptive for iPhone)
              if (codeRepeatTimestamps.length >= REQUIRED_VOTES) {
                const lastTwo = codeRepeatTimestamps.slice(-2);
                const deltaT = (lastTwo[1] - lastTwo[0]) * 1000; // ms
                const symbolMs = parseFloat(document.getElementById('spectralSymbolDuration').value);
                const expectedRepeatMs = PN31_CODE.length * symbolMs;
                
                // Cadence: allow only full-code repeat on iPhone (filter symbol-spaced coincidences)
                const tolerance = 0.5;
                const cadenceMatch = Math.abs(deltaT - expectedRepeatMs) <= expectedRepeatMs * tolerance;
                
                // Per-symbol cadence only allowed off iPhone mode
                const perSymbolMatch = !isIphoneMode && Math.abs(deltaT - symbolMs) <= symbolMs * 0.5;
                const cadenceOk = cadenceMatch || perSymbolMatch;
                
                console.log(`  ‚îú‚îÄ [cadence] Œît=${deltaT.toFixed(0)}ms (expected: ${expectedRepeatMs.toFixed(0)}ms or ${symbolMs.toFixed(0)}ms) ${cadenceOk?'‚úÖ':'‚ùå'}`);
                
                // Layer 6: POLARITY CONSISTENCY (blocking on iPhone)
                const polarities = window.detectionPolarities.slice(-2);
                const polarityConsistent = polarities[0] === polarities[1];
                const polarityPass = isIphoneMode ? polarityConsistent : true;
                console.log(`  ‚îú‚îÄ [polarity] ${polarities.map(p => p > 0 ? '+' : '-').join(', ')} ${polarityConsistent ? '‚úÖ consistent' : '‚ö†Ô∏è mixed'}`);
                
            // Layer 7: TX VALIDATION (MANDATORY) - Block false positives from ambient noise
            const detections = window.detectionHistory.slice(-2);
            const allTxOn = detections.every(d => d.txWasRunning);
            const txValidationPass = isOverAirMode ? true : allTxOn;
            console.log(`  ‚îú‚îÄ [TX validation] ${txValidationPass ? (isOverAirMode ? '‚úÖ Bypassed (Over-Air Mode)' : '‚úÖ TX was ON') : '‚ùå TX was OFF - BLOCKING UNLOCK'}`);
            
            if (cadenceOk && txValidationPass && polarityPass) {
              // üéâ UNLOCK!
              fsmState = 'UNLOCKED';
              fsmLockoutUntil = now + COOLDOWN_DURATION;
              presenceVerified = true;
              
              const badge = document.getElementById('presenceBadge');
              badge.textContent = 'üîì UNLOCKED';
              badge.classList.add('verified');
              
              // Log detection quality for analysis
              console.log(`üéâüéâüéâ FSM: CODE_LOCK ‚Üí UNLOCKED üéâüéâüéâ`);
              console.log(`  ‚îú‚îÄ Detections: ${REQUIRED_VOTES}/${REQUIRED_VOTES} (interval: ${deltaT.toFixed(0)}ms)`);
              console.log(`  ‚îú‚îÄ Correlations: [${detections.map(d => d.correlation.toFixed(3)).join(', ')}]`);
              console.log(`  ‚îú‚îÄ Polarity: ${polarityConsistent ? '‚úÖ consistent' : '‚ö†Ô∏è mixed'}`);
              console.log(`  ‚îú‚îÄ TX validation: ${isOverAirMode ? '‚úÖ bypassed (Over-Air Mode)' : '‚úÖ TX was ON for all detections'}`);
              console.log(`  ‚îî‚îÄ Cooldown: ${COOLDOWN_DURATION}s`);
              
              // Warning if mixed polarity (diagnostic only)
              if (!polarityConsistent) {
                console.warn(`‚ö†Ô∏è Mixed polarity detected - signal may have interference`);
              }
              
              updateFSMStateDisplay();
              
              // Reset to IDLE after cooldown
              setTimeout(() => {
                fsmState = 'IDLE';
                fsmStateStartTime = audioContext.currentTime;
                presenceVerified = false;
                window.detectionHistory = [];
                window.detectionPolarities = [];
                const badge = document.getElementById('presenceBadge');
                badge.textContent = '‚è≥ Listening...';
                badge.classList.remove('verified');
                console.log('üîÑ Cooldown complete - FSM reset to IDLE');
                updateFSMStateDisplay();
              }, COOLDOWN_DURATION * 1000);
            } else if (!txValidationPass) {
              // TX was off - reject as false positive (unless Over-Air Mode)
              console.log(`  ‚îî‚îÄ ‚ùå TX VALIDATION FAILED: TX was off - rejecting as ambient noise false positive`);
              // Clear oldest detection to allow new pattern
              codeRepeatTimestamps.shift();
              window.detectionPolarities.shift();
            } else {
                  console.log(`  ‚îî‚îÄ ‚ùå Cadence check failed - waiting for next detection`);
                  // Clear oldest detection to allow new pattern
                  codeRepeatTimestamps.shift();
                  window.detectionPolarities.shift();
                }
              }
            } else {
              // Log why validation failed
              if (!corePass) {
                if (!corrPass) console.log(`  ‚îî‚îÄ ‚ùå Correlation too low: ${correlation.toFixed(3)} < ${CORR_THRESHOLD}`);
                if (!psrPass) console.log(`  ‚îî‚îÄ ‚ùå PSR too low: ${peakToSidelobeRatio.toFixed(1)}dB < ${PSR_THRESHOLD}dB`);
                if (!zPass) console.log(`  ‚îî‚îÄ ‚ùå Z-score too low: ${zScore.toFixed(2)} < ${Z_THRESHOLD}`);
              }
              if (!medianDeltaValidation) {
                console.log(`  ‚îî‚îÄ ‚ùå Median Œî too low: ${medianDelta.toFixed(2)}dB < ${MEDIAN_DELTA_THRESHOLD.toFixed(2)}dB`);
              }
            }
          }
          
          // ===== STATE: UNLOCKED =====
          // (Nothing to do here - just wait for cooldown to expire)
        }
      } else {
        const vetoJump = broadbandPower - spectralBroadbandEMA;
        console.log(`‚ö†Ô∏è Loudness veto active: broadband=${broadbandPower.toFixed(2)}dB, EMA=${spectralBroadbandEMA.toFixed(2)}dB, jump=${vetoJump.toFixed(2)}dB (>12dB threshold)`);
      }
    }
    
    function computeCorrelation(signal, code) {
      // Normalized correlation between signal and code
      if (signal.length !== code.length) return 0;
      
      let sum = 0;
      let signalSq = 0;
      let codeSq = 0;
      
      for (let i = 0; i < signal.length; i++) {
        sum += signal[i] * code[i];
        signalSq += signal[i] * signal[i];
        codeSq += code[i] * code[i];
      }
      
      const denom = Math.sqrt(signalSq * codeSq);
      return denom > 0.001 ? sum / denom : 0;
    }

    // ==================== LEGACY NOTCH RX ====================
    
    async function startLegacyRX() {
      
      rxRunning = true;
      document.getElementById('startRxBtn').disabled = true;
      document.getElementById('stopRxBtn').disabled = false;
      document.getElementById('rxStatus').textContent = 'Listening...';
      
      // Set up mic pipeline: Mic -> HPF -> Analyser
      micSource = audioContext.createMediaStreamSource(micStream);
      
      const hpf = audioContext.createBiquadFilter();
      hpf.type = 'highpass';
      hpf.frequency.value = 200;
      
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 4096;
      analyser.smoothingTimeConstant = 0.8;
      
      micSource.connect(hpf);
      hpf.connect(analyser);
      
      // Reset detection state
      hitTimestamps = [];
      lastHitTime = 0;
      lastDropDetectionTime = 0;
      totalHitsDetected = 0;
      bandFloors = { notch: -120, guardLo: -120, guardHi: -120 };
      bandHistory = { notch: [], guardLo: [], guardHi: [] };
      dropFrameCount = 0;
      
      // Get parameters for logging
      const notchLow = parseFloat(document.getElementById('notchLow').value);
      const notchHigh = parseFloat(document.getElementById('notchHigh').value);
      const guardLoLow = parseFloat(document.getElementById('guardLoLow').value);
      const guardLoHigh = parseFloat(document.getElementById('guardLoHigh').value);
      const guardHiLow = parseFloat(document.getElementById('guardHiLow').value);
      const guardHiHigh = parseFloat(document.getElementById('guardHiHigh').value);
      const ratioThreshold = parseFloat(document.getElementById('ratioThreshold').value);
      const hitsRequired = parseInt(document.getElementById('hitsRequired').value);
      const minInterHit = parseFloat(document.getElementById('minInterHit').value);
      
      console.log('‚úÖ RX INITIALIZED: Microphone active, starting detection');
      console.log(`  ‚îú‚îÄ Sample rate: ${audioContext.sampleRate}Hz`);
      console.log(`  ‚îú‚îÄ FFT size: ${analyser.fftSize}`);
      console.log(`  ‚îú‚îÄ Notch band: ${notchLow}-${notchHigh}Hz`);
      console.log(`  ‚îú‚îÄ Guard bands: ${guardLoLow}-${guardLoHigh}Hz, ${guardHiLow}-${guardHiHigh}Hz`);
      console.log(`  ‚îî‚îÄ Detection: ratio>${ratioThreshold}dB, hits=${hitsRequired}, spacing>${minInterHit}s`);
      
      // Start detection loop
      rxInterval = setInterval(detectDrop, 120);
    }

    function detectDrop() {
      if (!rxRunning || !analyser) return;
      
      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Float32Array(bufferLength);
      analyser.getFloatFrequencyData(dataArray);
      
      const sampleRate = audioContext.sampleRate;
      const binHz = (sampleRate / 2) / (bufferLength - 1);
      
      // Get band ranges
      const notchLow = parseFloat(document.getElementById('notchLow').value);
      const notchHigh = parseFloat(document.getElementById('notchHigh').value);
      const guardLoLow = parseFloat(document.getElementById('guardLoLow').value);
      const guardLoHigh = parseFloat(document.getElementById('guardLoHigh').value);
      const guardHiLow = parseFloat(document.getElementById('guardHiLow').value);
      const guardHiHigh = parseFloat(document.getElementById('guardHiHigh').value);
      
      // Compute band powers
      const notchPower = computeBandPower(dataArray, binHz, notchLow, notchHigh);
      const guardLoPower = computeBandPower(dataArray, binHz, guardLoLow, guardLoHigh);
      const guardHiPower = computeBandPower(dataArray, binHz, guardHiLow, guardHiHigh);
      const guardAvg = (guardLoPower + guardHiPower) / 2;
      
      // Update rolling history for baseline (keep ~5 seconds at 120ms intervals = ~42 frames)
      const maxHistoryLength = 42;
      bandHistory.notch.push(notchPower);
      bandHistory.guardLo.push(guardLoPower);
      bandHistory.guardHi.push(guardHiPower);
      if (bandHistory.notch.length > maxHistoryLength) {
        bandHistory.notch.shift();
        bandHistory.guardLo.shift();
        bandHistory.guardHi.shift();
      }
      
      // Update EMA floors
      const alpha = 0.05;
      if (notchPower <= bandFloors.notch + 3) {
        bandFloors.notch = bandFloors.notch * (1 - alpha) + notchPower * alpha;
      }
      if (guardLoPower <= bandFloors.guardLo + 3) {
        bandFloors.guardLo = bandFloors.guardLo * (1 - alpha) + guardLoPower * alpha;
      }
      if (guardHiPower <= bandFloors.guardHi + 3) {
        bandFloors.guardHi = bandFloors.guardHi * (1 - alpha) + guardHiPower * alpha;
      }
      
      const ratio = guardAvg - notchPower;
      
      // Display
      document.getElementById('notchPower').textContent = notchPower.toFixed(1) + ' dB';
      document.getElementById('guardPower').textContent = guardAvg.toFixed(1) + ' dB';
      document.getElementById('ratioPower').textContent = ratio.toFixed(1) + ' dB';
      
      // Detection logic - look for TEMPORARY notch dips, not static ratios
      const ratioThreshold = parseFloat(document.getElementById('ratioThreshold').value);
      const minInterHit = parseFloat(document.getElementById('minInterHit').value);
      const hitsRequired = parseInt(document.getElementById('hitsRequired').value);
      const windowS = parseFloat(document.getElementById('windowS').value);
      const now = audioContext.currentTime;
      
      // Only check for drops once we have enough history
      let dropDetected = false;
      if (bandHistory.notch.length >= 20) {
        // Compute median baseline for each band
        const notchMedian = computeMedian([...bandHistory.notch]);
        const guardLoMedian = computeMedian([...bandHistory.guardLo]);
        const guardHiMedian = computeMedian([...bandHistory.guardHi]);
        const guardAvgMedian = (guardLoMedian + guardHiMedian) / 2;
        
        // Check if this frame shows the drop pattern:
        // 1. Notch is significantly BELOW its baseline
        // 2. Guards are near their baseline (stable)
        // 3. Ratio threshold is met
        const notchDrop = notchMedian - notchPower;  // Positive = notch is lower
        const guardLoStable = Math.abs(guardLoPower - guardLoMedian);
        const guardHiStable = Math.abs(guardHiPower - guardHiMedian);
        
        const notchDropThreshold = 2.5;  // dB below baseline
        const guardStableThreshold = 8.0;  // dB tolerance - relaxed for real-world audio
        const minAbsoluteRatio = 1.5;  // Minimum absolute ratio
        
        // Log detection analysis every 2 seconds
        const shouldLog = (Math.floor(now * 0.5) !== Math.floor((now - 0.120) * 0.5));
        
        if (shouldLog && bandHistory.notch.length >= 20) {
          console.log(`üéØ RX ANALYSIS @ t=${now.toFixed(3)}s:`);
          console.log(`  ‚îú‚îÄ Notch: ${notchPower.toFixed(2)}dB (baseline: ${notchMedian.toFixed(2)}dB, drop: ${notchDrop.toFixed(2)}dB) ${notchDrop >= notchDropThreshold ? '‚úì' : '‚úó'}`);
          console.log(`  ‚îú‚îÄ GuardLo: ${guardLoPower.toFixed(2)}dB (baseline: ${guardLoMedian.toFixed(2)}dB, drift: ${guardLoStable.toFixed(2)}dB) ${guardLoStable <= guardStableThreshold ? '‚úì' : '‚úó'}`);
          console.log(`  ‚îú‚îÄ GuardHi: ${guardHiPower.toFixed(2)}dB (baseline: ${guardHiMedian.toFixed(2)}dB, drift: ${guardHiStable.toFixed(2)}dB) ${guardHiStable <= guardStableThreshold ? '‚úì' : '‚úó'}`);
          console.log(`  ‚îú‚îÄ Ratio: ${ratio.toFixed(2)}dB (threshold: ${ratioThreshold}dB) ${ratio >= ratioThreshold ? '‚úì' : '‚úó'}`);
          console.log(`  ‚îú‚îÄ Frame count: ${dropFrameCount}/2 frames`);
          console.log(`  ‚îî‚îÄ Drops detected so far: ${totalHitsDetected} (need ${hitsRequired} for verification)`);
        }
        
        if (notchDrop >= notchDropThreshold && 
            guardLoStable <= guardStableThreshold &&
            guardHiStable <= guardStableThreshold &&
            ratio >= ratioThreshold &&
            ratio >= minAbsoluteRatio) {  // Additional absolute threshold
          dropFrameCount++;
          
          console.log(`  ‚úì Pattern match! dropFrameCount=${dropFrameCount}`);
          
          // Require pattern for 2-3 consecutive frames to reduce false positives
          if (dropFrameCount >= 2 && (now - lastHitTime) >= minInterHit) {
            dropDetected = true;
            console.log(`  üéâ DROP DETECTED after ${dropFrameCount} consecutive frames`);
          }
        } else {
          // Allow one frame gap before resetting
          if (dropFrameCount > 0) {
            dropFrameCount = Math.max(0, dropFrameCount - 1);
          }
        }
      }
      
      if (dropDetected) {
        // Apply cooldown to prevent multiple detections of same drop (200ms)
        const cooldownPeriod = 0.2; // seconds
        const timeSinceLastDrop = now - lastDropDetectionTime;
        
        if (timeSinceLastDrop >= cooldownPeriod) {
          // Drop detected - register as valid hit if spacing is good
          lastDropDetectionTime = now;
          dropFrameCount = 0;  // Reset after registering drop
          
          // Check spacing from last hit
          const timeSinceLastHit = now - lastHitTime;
          
          if (timeSinceLastHit >= minInterHit) {
            // Valid drop with good spacing
            hitTimestamps.push(now);
            lastHitTime = now;
            totalHitsDetected++;
            
            document.getElementById('lastHitTime').textContent = new Date().toLocaleTimeString();
            document.getElementById('totalHits').textContent = totalHitsDetected;
            document.getElementById('individualDrops').textContent = totalHitsDetected;
            
            console.log(`‚úÖ VALID DROP #${totalHitsDetected} detected at t=${now.toFixed(3)}s. Ratio: ${ratio.toFixed(2)}dB, Spacing: ${(timeSinceLastHit).toFixed(2)}s`);
          } else {
            console.log(`Drop detected but too close to previous (${(timeSinceLastHit).toFixed(2)}s < ${minInterHit}s) - ignoring`);
          }
        } else {
          // Drop detected but still in cooldown period - ignore
          const cooldownRemaining = ((cooldownPeriod - timeSinceLastDrop) * 1000).toFixed(0);
          console.log(`Drop detected but in cooldown (${cooldownRemaining}ms remaining) - ignoring`);
        }
      }
      
      // Clean old valid pairs
      hitTimestamps = hitTimestamps.filter(t => (now - t) <= windowS);
      document.getElementById('validPairs').textContent = hitTimestamps.length;
      document.getElementById('hitsReq').textContent = hitsRequired;
      
      // Check verification (only in LEGACY mode)
      if (currentMode === 'legacy' && hitTimestamps.length >= hitsRequired && !presenceVerified) {
        presenceVerified = true;
        const badge = document.getElementById('presenceBadge');
        badge.textContent = '‚úÖ Presence Verified!';
        badge.classList.add('verified');
        console.log('PRESENCE VERIFIED!');
      }
    }

    function computeBandPower(dataArray, binHz, lowHz, highHz) {
      const lowBin = Math.floor(lowHz / binHz);
      const highBin = Math.ceil(highHz / binHz);
      
      let sum = 0;
      let count = 0;
      for (let i = lowBin; i <= highBin && i < dataArray.length; i++) {
        const db = dataArray[i];
        // Skip -Infinity bins (silence), don't clamp to -120
        if (isFinite(db)) {
          sum += db;
          count++;
        }
      }
      
      // Return average, or -140dB if no valid bins (deeper floor for true silence)
      return count > 0 ? sum / count : -140;
    }
    
    function computeMedian(arr) {
      if (arr.length === 0) return -120;
      const sorted = arr.slice().sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      if (sorted.length % 2 === 0) {
        return (sorted[mid - 1] + sorted[mid]) / 2;
      }
      return sorted[mid];
    }

    function stopRX() {
      if (!rxRunning) return;
      
      rxRunning = false;
      
      if (rxInterval) {
        clearInterval(rxInterval);
        rxInterval = null;
      }
      
      if (micSource) {
        micSource.disconnect();
        micSource = null;
      }
      
      if (micStream) {
        micStream.getTracks().forEach(track => track.stop());
        micStream = null;
      }
      
      analyser = null;
      
      // Reset baseline UI
      document.getElementById('baselineStatus').textContent = 'Stopped';
      document.getElementById('baselineNoise').textContent = 'Not calibrated';
      document.getElementById('detectionThreshold').textContent = '‚Äî';
      document.getElementById('corrPeak').textContent = '‚Äî';
      document.getElementById('corrZScore').textContent = '‚Äî';
      document.getElementById('corrPSR').textContent = '‚Äî';
      
      document.getElementById('startRxBtn').disabled = false;
      document.getElementById('stopRxBtn').disabled = true;
      document.getElementById('recalibrateBtn').disabled = true;
      document.getElementById('rxStatus').textContent = 'Stopped';
    }

    function resetRX() {
      hitTimestamps = [];
      lastHitTime = 0;
      lastDropDetectionTime = 0;
      totalHitsDetected = 0;
      presenceVerified = false;
      bandFloors = { notch: -120, guardLo: -120, guardHi: -120 };
      bandHistory = { notch: [], guardLo: [], guardHi: [] };
      dropFrameCount = 0;
      
      document.getElementById('individualDrops').textContent = '0';
      document.getElementById('validPairs').textContent = '0';
      document.getElementById('lastHitTime').textContent = '‚Äî';
      document.getElementById('totalHits').textContent = '0';
      
      const badge = document.getElementById('presenceBadge');
      badge.textContent = '‚è≥ Waiting for Presence...';
      badge.classList.remove('verified');
    }

    // ==================== OFFLINE ENCODER ====================
    
    let offlineOriginalBuffer = null;
    let offlineEncodedBuffer = null;
    
    async function processOfflineFile() {
      const fileInput = document.getElementById('offlineFile');
      if (fileInput.files.length === 0) {
        alert('Please upload an audio file first');
        return;
      }
      
      if (!audioContext) {
        await initAudioContext();
      }
      
      document.getElementById('offlineStatus').textContent = 'Loading file...';
      document.getElementById('processOfflineBtn').disabled = true;
      
      try {
        const file = fileInput.files[0];
        const arrayBuffer = await file.arrayBuffer();
        offlineOriginalBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        console.log('üéõÔ∏è OFFLINE ENCODER: File loaded');
        console.log(`  ‚îú‚îÄ File: ${file.name}`);
        console.log(`  ‚îú‚îÄ Duration: ${offlineOriginalBuffer.duration.toFixed(2)}s`);
        console.log(`  ‚îú‚îÄ Channels: ${offlineOriginalBuffer.numberOfChannels}`);
        console.log(`  ‚îú‚îÄ Sample rate: ${offlineOriginalBuffer.sampleRate}Hz`);
        console.log(`  ‚îî‚îÄ Mode: ${currentMode}`);
        
        document.getElementById('offlineDuration').textContent = offlineOriginalBuffer.duration.toFixed(1) + 's';

        if (currentMode === 'spectral') {
          await processOfflineSpectral();
        } else {
          await processOfflineLegacy();
        }
      } catch (e) {
        console.error('‚ùå OFFLINE ENCODING ERROR:', e);
        document.getElementById('offlineStatus').textContent = 'Error: ' + e.message;
        document.getElementById('processOfflineBtn').disabled = false;
      }
    }
    
    async function processOfflineSpectral() {
      document.getElementById('offlineStatus').textContent = 'Encoding spectral beacon...';
      
      const centerFreq = parseFloat(document.getElementById('offlineSpectralCenter').value);
      const binSpacing = parseFloat(document.getElementById('offlineSpectralSpacing').value);
      const symbolDurationMs = parseFloat(document.getElementById('offlineSpectralDuration').value);
      const repeats = parseInt(document.getElementById('offlineSpectralRepeats').value);
      const symbolGain = parseFloat(document.getElementById('offlineSpectralGain').value);
      const startTime = parseFloat(document.getElementById('offlineSpectralStart').value);
      
      const freqA = centerFreq - binSpacing / 2;
      const freqB = centerFreq + binSpacing / 2;
      const symbolDurationS = symbolDurationMs / 1000;
      
      console.log('üéØ SPECTRAL OFFLINE ENCODING:');
      console.log(`  ‚îú‚îÄ Freq A: ${freqA}Hz, B: ${freqB}Hz (spacing: ${binSpacing}Hz)`);
      console.log(`  ‚îú‚îÄ Symbol duration: ${symbolDurationMs}ms (¬±${symbolGain}dB)`);
      console.log(`  ‚îú‚îÄ Code: PN-31 √ó ${repeats} repeats = ${PN31_CODE.length * repeats} symbols`);
      console.log(`  ‚îî‚îÄ Total duration: ${(PN31_CODE.length * repeats * symbolDurationS).toFixed(2)}s`);
      
      const offlineCtx = new OfflineAudioContext(
        offlineOriginalBuffer.numberOfChannels,
        offlineOriginalBuffer.length,
        offlineOriginalBuffer.sampleRate
      );
      
      const source = offlineCtx.createBufferSource();
      source.buffer = offlineOriginalBuffer;
      
      // Create filters for bins A and B
      const filterA = offlineCtx.createBiquadFilter();
      filterA.type = 'peaking';
      filterA.frequency.value = freqA;
      filterA.Q.value = 10; // Wider bandwidth (600Hz) for stronger over-air signal
      filterA.gain.value = 0;
      
      const filterB = offlineCtx.createBiquadFilter();
      filterB.type = 'peaking';
      filterB.frequency.value = freqB;
      filterB.Q.value = 10; // Wider bandwidth (600Hz) for stronger over-air signal
      filterB.gain.value = 0;
      
      source.connect(filterA);
      filterA.connect(filterB);
      filterB.connect(offlineCtx.destination);
      
      // Schedule symbols
      const fadeTime = 0.004; // 4ms fade to match live
      const jitterMs = 12; // ¬±12ms jitter
      let symbolsEncoded = 0;
      
      for (let repeat = 0; repeat < repeats; repeat++) {
        for (let i = 0; i < PN31_CODE.length; i++) {
          const jitter = (Math.random() * 2 - 1) * (jitterMs / 1000);
          const symbolTime = startTime + (repeat * PN31_CODE.length + i) * symbolDurationS + jitter;
          
          if (symbolTime + symbolDurationS <= offlineOriginalBuffer.duration) {
            const symbol = PN31_CODE[i];
            const gainA = symbol > 0 ? -symbolGain : symbolGain;
            const gainB = symbol > 0 ? symbolGain : -symbolGain;
            
            // DEBUG: Log first 10 symbols
            if (repeat === 0 && i < 10) {
              console.log(`  Symbol[${i}]: code=${symbol.toFixed(1)}, gainA=${gainA.toFixed(1)}dB, gainB=${gainB.toFixed(1)}dB`);
            }
            
            // Schedule smooth ramps
            filterA.gain.setValueAtTime(0, symbolTime);
            filterA.gain.linearRampToValueAtTime(gainA, symbolTime + fadeTime);
            filterA.gain.setValueAtTime(gainA, symbolTime + symbolDurationS - fadeTime);
            filterA.gain.linearRampToValueAtTime(0, symbolTime + symbolDurationS);
            
            filterB.gain.setValueAtTime(0, symbolTime);
            filterB.gain.linearRampToValueAtTime(gainB, symbolTime + fadeTime);
            filterB.gain.setValueAtTime(gainB, symbolTime + symbolDurationS - fadeTime);
            filterB.gain.linearRampToValueAtTime(0, symbolTime + symbolDurationS);
            
            symbolsEncoded++;
            
            if (i === 0) {
              console.log(`  ‚úì Repeat ${repeat + 1}/${repeats}: t=${symbolTime.toFixed(2)}s, symbol=${symbol > 0 ? '+1' : '-1'}, gainA=${gainA.toFixed(2)}dB, gainB=${gainB.toFixed(2)}dB`);
            }
          }
        }
      }
      
      console.log(`  ‚úÖ Scheduled ${symbolsEncoded} symbols`);
      
      source.start(0);
      offlineEncodedBuffer = await offlineCtx.startRendering();
      
      console.log('‚úÖ SPECTRAL ENCODING COMPLETE');
      
      await finalizeOfflineEncoding(symbolsEncoded);
    }
    
    async function processOfflineLegacy() {
      document.getElementById('offlineStatus').textContent = 'Processing legacy notch drops...';
      
      const dropCenter = parseFloat(document.getElementById('offlineDropCenter').value);
      const dropBw = parseFloat(document.getElementById('offlineDropBw').value);
      const dropDepth = parseFloat(document.getElementById('offlineDropDepth').value);
      const dropLenMs = parseFloat(document.getElementById('offlineDropLen').value);
      const dropStart = parseFloat(document.getElementById('offlineDropStart').value);
      const dropCount = parseInt(document.getElementById('offlineDropCount').value);
      
      console.log('üéõÔ∏è LEGACY OFFLINE ENCODING:');
      console.log(`  ‚îú‚îÄ Drops: ${dropCount} √ó ${dropLenMs}ms @ ${dropDepth}dB`);
      console.log(`  ‚îú‚îÄ Frequency: ${dropCenter}Hz (BW: ${dropBw}Hz, Q: ${(dropCenter/dropBw).toFixed(2)})`);
      console.log(`  ‚îî‚îÄ Starting at ${dropStart}s`);
      
      const offlineCtx = new OfflineAudioContext(
        offlineOriginalBuffer.numberOfChannels,
        offlineOriginalBuffer.length,
        offlineOriginalBuffer.sampleRate
      );
        
        // Create source
        const source = offlineCtx.createBufferSource();
        source.buffer = offlineOriginalBuffer;
        
        // Create bandpass filter centered at dropCenter with controllable bandwidth
        // Using a lowshelf + highshelf approach for more audible effect
        const lowshelf = offlineCtx.createBiquadFilter();
        lowshelf.type = 'lowshelf';
        lowshelf.frequency.value = dropCenter * 0.7; // Start rolloff below center
        lowshelf.gain.value = 0;
        
        const highshelf = offlineCtx.createBiquadFilter();
        highshelf.type = 'highshelf';
        highshelf.frequency.value = dropCenter * 1.3; // Start rolloff above center
        highshelf.gain.value = 0;
        
        // Create main notch with wider Q for audibility
        const notch = offlineCtx.createBiquadFilter();
        notch.type = 'peaking';
        notch.frequency.value = dropCenter;
        notch.Q.value = 2.0; // Much lower Q = wider notch = more audible
        notch.gain.value = 0;
        
        // Connect graph: source -> lowshelf -> highshelf -> notch -> destination
        source.connect(lowshelf);
        lowshelf.connect(highshelf);
        highshelf.connect(notch);
        notch.connect(offlineCtx.destination);
        
        // Schedule drops
        const dropLenS = dropLenMs / 1000;
        const fadeTime = 0.05; // 50ms fade for smoother transition
        const spacing = 3.0; // 3 seconds between drops
        
        let dropsScheduled = 0;
        for (let i = 0; i < dropCount; i++) {
          const dropTime = dropStart + (i * spacing);
          if (dropTime + dropLenS <= offlineOriginalBuffer.duration) {
            // Animate all three filters together for compound effect
            
            // Lowshelf: reduce lows during drop
            lowshelf.gain.setValueAtTime(0, dropTime);
            lowshelf.gain.linearRampToValueAtTime(dropDepth * 0.3, dropTime + fadeTime);
            lowshelf.gain.setValueAtTime(dropDepth * 0.3, dropTime + dropLenS - fadeTime);
            lowshelf.gain.linearRampToValueAtTime(0, dropTime + dropLenS);
            
            // Highshelf: reduce highs during drop
            highshelf.gain.setValueAtTime(0, dropTime);
            highshelf.gain.linearRampToValueAtTime(dropDepth * 0.3, dropTime + fadeTime);
            highshelf.gain.setValueAtTime(dropDepth * 0.3, dropTime + dropLenS - fadeTime);
            highshelf.gain.linearRampToValueAtTime(0, dropTime + dropLenS);
            
            // Main notch: strong reduction at center frequency
            notch.gain.setValueAtTime(0, dropTime);
            notch.gain.linearRampToValueAtTime(dropDepth, dropTime + fadeTime);
            notch.gain.setValueAtTime(dropDepth, dropTime + dropLenS - fadeTime);
            notch.gain.linearRampToValueAtTime(0, dropTime + dropLenS);
            
            dropsScheduled++;
            
            console.log(`  ‚úÖ Drop ${i+1}: t=${dropTime.toFixed(1)}s ‚Üí ${(dropTime+dropLenS).toFixed(1)}s`);
            console.log(`      Center: ${dropDepth}dB @ ${dropCenter}Hz, Shelves: ${(dropDepth*0.3).toFixed(1)}dB`);
          }
        }
      
      source.start(0);
      offlineEncodedBuffer = await offlineCtx.startRendering();
      
      console.log(`‚úÖ LEGACY ENCODING COMPLETE: ${dropsScheduled} drops encoded`);
      
      await finalizeOfflineEncoding(dropsScheduled);
    }
    
    async function finalizeOfflineEncoding(itemsEncoded) {
      const originalBlob = await bufferToWav(offlineOriginalBuffer);
      const encodedBlob = await bufferToWav(offlineEncodedBuffer);
      
      const originalAudio = document.getElementById('originalAudio');
      const encodedAudio = document.getElementById('encodedAudio');
      
      originalAudio.src = URL.createObjectURL(originalBlob);
      encodedAudio.src = URL.createObjectURL(encodedBlob);
      
      document.getElementById('offlinePlayback').style.display = 'block';
      document.getElementById('offlineStatus').textContent = `Complete! Encoded ${itemsEncoded} ${currentMode === 'spectral' ? 'symbols' : 'drops'}`;
      document.getElementById('offlineDropsEncoded').textContent = itemsEncoded;
      document.getElementById('processOfflineBtn').disabled = false;
      document.getElementById('downloadOfflineBtn').disabled = false;
      
      console.log('‚úÖ Offline encoding finalized - ready for playback/download');
    }
    
    function downloadEncodedFile() {
      if (!offlineEncodedBuffer) {
        alert('No encoded file available. Process a file first.');
        return;
      }
      
      bufferToWav(offlineEncodedBuffer).then(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'encoded-with-drops.wav';
        a.click();
        URL.revokeObjectURL(url);
        console.log('‚úÖ Downloaded encoded file');
      });
    }
    
    async function bufferToWav(buffer) {
      const numberOfChannels = buffer.numberOfChannels;
      const length = buffer.length;
      const sampleRate = buffer.sampleRate;
      const bitDepth = 16;
      
      const bytesPerSample = bitDepth / 8;
      const blockAlign = numberOfChannels * bytesPerSample;
      
      const dataSize = length * blockAlign;
      const bufferSize = 44 + dataSize;
      
      const arrayBuffer = new ArrayBuffer(bufferSize);
      const view = new DataView(arrayBuffer);
      
      // WAV header
      const writeString = (offset, string) => {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      };
      
      writeString(0, 'RIFF');
      view.setUint32(4, bufferSize - 8, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true); // fmt chunk size
      view.setUint16(20, 1, true); // PCM
      view.setUint16(22, numberOfChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bitDepth, true);
      writeString(36, 'data');
      view.setUint32(40, dataSize, true);
      
      // Write audio data
      let offset = 44;
      for (let i = 0; i < length; i++) {
        for (let ch = 0; ch < numberOfChannels; ch++) {
          const sample = Math.max(-1, Math.min(1, buffer.getChannelData(ch)[i]));
          const int16 = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
          view.setInt16(offset, int16, true);
          offset += 2;
        }
      }
      
      return new Blob([arrayBuffer], { type: 'audio/wav' });
    }

    // ==================== EVENT LISTENERS ====================
    
    // Mode toggle
    document.querySelectorAll('input[name="detectionMode"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        currentMode = e.target.value;
        
        // Update UI visibility for live sections
        if (currentMode === 'spectral') {
          document.getElementById('spectralTxParams').style.display = 'block';
          document.getElementById('legacyTxParams').style.display = 'none';
          document.getElementById('spectralRxSection').style.display = 'block';
          document.getElementById('legacyRxSection').style.display = 'none';
          document.getElementById('offlineSpectralParams').style.display = 'block';
          document.getElementById('offlineLegacyParams').style.display = 'none';
        } else {
          document.getElementById('spectralTxParams').style.display = 'none';
          document.getElementById('legacyTxParams').style.display = 'block';
          document.getElementById('spectralRxSection').style.display = 'none';
          document.getElementById('legacyRxSection').style.display = 'block';
          document.getElementById('offlineSpectralParams').style.display = 'none';
          document.getElementById('offlineLegacyParams').style.display = 'block';
        }
        
        console.log(`‚úì Mode switched to: ${currentMode.toUpperCase()}`);
      });
    });
    
    // Offline encoder
    document.getElementById('processOfflineBtn').addEventListener('click', processOfflineFile);
    document.getElementById('downloadOfflineBtn').addEventListener('click', downloadEncodedFile);
    
    // Global audio
    document.getElementById('startAudioBtn').addEventListener('click', async () => {
      await initAudioContext();
      document.getElementById('startAudioBtn').style.display = 'none';
      document.getElementById('resumeAudioBtn').style.display = 'inline-block';
      updateStatus('Ready');
    });

    document.getElementById('resumeAudioBtn').addEventListener('click', async () => {
      if (audioContext && audioContext.state === 'suspended') {
        await audioContext.resume();
        updateCtxState();
        updateStatus('Resumed');
      }
    });

    // Live TX
    document.getElementById('startTxBtn').addEventListener('click', startTX);
    document.getElementById('stopTxBtn').addEventListener('click', stopTX);
    document.getElementById('smokeTestBtn').addEventListener('click', () => {
      applySmokeTest();
      setTimeout(() => startTX(), 500);
    });

    // RX
    document.getElementById('startRxBtn').addEventListener('click', startRX);
    document.getElementById('stopRxBtn').addEventListener('click', stopRX);
    document.getElementById('resetRxBtn').addEventListener('click', resetRX);
    document.getElementById('recalibrateBtn').addEventListener('click', () => {
      if (rxRunning && currentMode === 'spectral') {
        // Reset baseline state
        baselineCalibrated = false;
        baselineCalibrationSamples = [];
        spectralConsecutiveHits = 0;
        presenceVerified = false;
        
        // Reset badge
        const badge = document.getElementById('presenceBadge');
        badge.textContent = '‚è≥ Recalibrating...';
        badge.classList.remove('verified');
        
        // Update UI
        document.getElementById('baselineStatus').textContent = 'Recalibrating... 0/70';
        document.getElementById('baselineNoise').textContent = 'Measuring...';
        document.getElementById('detectionThreshold').textContent = 'Computing...';
        document.getElementById('consecutiveHits').textContent = 'calibrating...';
        
        console.log('üîÑ RECALIBRATION STARTED - Measuring noise floor...');
        console.log('  ‚îî‚îÄ Make sure TX is OFF for accurate baseline!');
      }
    });

    // ==================== INIT ====================
    
    console.log('Presence Beacon loaded. Click "Start Audio" to begin.');
  </script>
</body>
</html>